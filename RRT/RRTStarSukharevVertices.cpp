#include "RRTStarSukharevVertices.h"
#include "ResultOutputer.h"
#include <CGAL/Polygon_2.h>
#include <CGAL/ch_graham_andrew.h>
#include <CGAL/convex_hull_2.h>
#include <boost/sort/sort.hpp>
#include "KDTree.h"

bool sortCompare(const pair<double, Point_2*> p1, const pair<double, Point_2*> p2) {
	return p1.first < p2.first;
}

typedef Polygon_2::Vertex_iterator VertexIterator;

vector<Point_2> availableVertices;
int availableVerticesSize;

RRTStarSukharevVertices::RRTStarSukharevVertices(NavigationEnvironment ne, const double r,  int const n):RRTStar(ne, r, n){
}

RRTStarSukharevVertices::RRTStarSukharevVertices(NavigationEnvironment ne, const double r, int const n, string experimentName) : RRTStar(ne, r, n) {
	this->experiment = experimentName;
}

RRTStarSukharevVertices::~RRTStarSukharevVertices(){
}

//backup sukharev grid
void RRTStarSukharevVertices::buildSukharev(Node* qInit, Node* qGoal, double distanceToGenerateRoute, string envName, int cellsSukharev) {
	NodeStar* qRand;
	NodeStar* qNear;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max(), unoptimizedCost = 0;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/grid_compare/RRT_Sukharev/";
	string simulationName = envName + "/rrtstar_sukharev_"+ to_string(cellsSukharev) + "_grid_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";

	string columns[] = {"iteration", "cost", "sample_time", "total_time", "nodes"};
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{fileByIteractionName, columns, columns + sizeOfData, fileSeparator};

	double planningTimeInit = clock();

	NodeStar* qInitStar = new NodeStar{ qInit };
	this->setRoot(qInitStar);
	this->stackNodes.push_back(qInitStar);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool activatePrint = false;

	int i = 0;
	int imgCount = 1; int lastQtdNodes = 0;
	double nextTime = 0;
	while (accumulatedTime <= n) {
		i++;
	//for (int i = 1; i <= this->n; i++) {
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		int sampleTimeInit = clock();

		qRand = new NodeStar{this->generateRandomNode()}; 
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Primeira tentativa de qNew: Grade de sukharev
		if (this->navigationSpace.getDispersionGrid().getGridSize() != 0 && nodeEncountered == 0) {
			NodeStar* qNewTemp;
			qNewTemp = this->createNewNodeBySukharevGrid(qNear, qRand);
			this->navigationSpace.putNodeInsideLimits(qNewTemp);
			int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
			Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);

			if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
				qNewSukharev->visite();
				qNew = new NodeStar{qNewSukharev};
				nodeEncountered = 1;
			} else {
				if (qNewSukharev != nullptr){
					if (collisionChecker.insideObstacle(qNewSukharev)) {
						qNewSukharev->visite();
					}
				}
			}
		}

		//Segunda tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}
	
		int sampleTimeEnd = clock();
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock();
		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);
			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;

			this->rewire(nodeNeighborhood, qMin, qNew);

			NodeStar* qPathGoal = nullptr; NodeStar* lastAntecessor = nullptr;
			
			if (MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute && collisionChecker.batchCollisionFreePath(qNew, qGoal)){
				lastAntecessor = (NodeStar*) qGoal->getAntecessor();
				if (lastAntecessor) {
					this->removeNode(lastAntecessor, qGoal);
				}
				this->insertNode(qNew, (NodeStar*)qGoal);
				foundedNewPath = true;
			}

			double currentCost=0;
			if (qGoal->getAntecessor()) {
				currentCost = ((NodeStar*)qGoal)->getCost();
			}

			if (foundedNewPath) {
				qPathGoal = (NodeStar*)qGoal;
				vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)getRoot(), (NodeStar*)qPathGoal);
				NodeStar* rGoal = routeNodes[0];
				NodeStar* rInit = routeNodes[1];
				//newCost = optimizePath(rInit, rGoal);*/
				newCost = currentCost;

				if (newCost < oldCost) {
					//unoptimizedCost = qPathGoal->getCost();
					Route* newRoute = new Route{ rInit, rGoal };
					newRoute->build();
					this->route = newRoute;
					oldCost = newCost;
					if (activatePrint) {
						displayTimeInit = clock(); /*INIT - DISPLAY TIME*/
						this->displayNow(folderPath + simulationName + "_founded_route_", i);
						displayTimeEnd = clock(); /*END - DISPLAY TIME*/
						activatePrint = false;
					}
				} else if (foundedNewPath) {
					this->removeNode(qNew, qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
						//((NodeStar*)qGoal)->updateCost();
					}
				}
				foundedNewPath = false;
			}
			//***FIM RRT-STAR***
		}

		int addNewNodeTimeEnd = clock();
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		int init = clock();
		accumulatedTime += (sampleTime + addNewNodeTime);
		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		} else {
			cost = 0;
		}
		float data[] = {i, cost, sampleTime, accumulatedTime, this->qtdNodes};
		//costsByIterationsOutputer->pushData(data, data + sizeOfData);

		if (!this->goal->getAntecessor() && (this->qtdNodes - lastQtdNodes) != 0) {
		//if (accumulatedTime <= 0.1 && (accumulatedTime - nextTime) >= 0.0003) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		} else if (accumulatedTime - nextTime >= (this->n / 100.0)) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			nextTime = accumulatedTime;
			imgCount++;
		}

		//Save the simulation to BMP file
		/*if (i % 250 == 0 && activatePrint) {
			this->displayNow(folderPath + simulationName, i);
		}*/
		double displayTime = ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		int end = clock();
		timeDataReport += (end - init) / double(CLOCKS_PER_SEC);// +displayTime;
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	//Display to final time
	this->displayNow(folderPath + simulationName, imgCount);
	float data[] = { i, ((NodeStar*)(this->route->getGoal()))->getCost(), 0, accumulatedTime, this->qtdNodes };
	costsByIterationsOutputer->pushData(data, data + sizeOfData);

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
}

void RRTStarSukharevVertices::buildVerticesKdTree(Node* qInit, Node * qGoal, double distanceToGenerateRoute, string envName, string dispersionName) {
	NodeStar* qRand;
	NodeStar* qNear;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max(), unoptimizedCost = 0;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/grid_compare/RRT_Vertices/";
	string simulationName = envName + "/rrtstar_vertices_byIteration_d" + dispersionName + "_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{fileByIteractionName, columns, columns + sizeOfData, fileSeparator};

	double planningTimeInit = clock();

	//necessary to maintaint the startSample flag equal true
	NodeStar* qInitStar = new NodeStar{qInit};
	this->setRoot(qInitStar);
	this->stackNodes.push_back(qInitStar);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool generatedByVertice = false;
	bool activatePrint = false;

	vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();
	vector<Point_2*> vlist;

	/*BEGIN - Formation of kdtrees with convex vertices - BEGIN*/
	for (int i = 0; i < obstacles.size(); i++) {
		vector<Point_2> obstacleVertices = obstacles[i]->getConvexVertices();
		for (int k = 0; k < obstacleVertices.size(); k++) {
			vlist.push_back(new Point_2{ obstacleVertices[k].x(), obstacleVertices[k].y() });
		}
	}

	KDTree* vtree = new KDTree(2, vlist.size());
	for (int i = 0; i < vlist.size(); i++) {
		vtree->insert(Point_2( vlist[i]->x(), vlist[i]->y() ));
	}
	vtree->build();
	/*END - Formation of kdtrees with convex vertices - END*/

	//for (int i = 1; i <= this->n; i++) {
	int i = 0;
	int imgCount = 1; int lastQtdNodes = 0;
	double nextTime = 0;
	while (accumulatedTime <= n) {
		i++;
		////this->displayNow(folderPath + simulationName, i);
		//if (i % 1000 == 0) {
		//	this->displayNow(folderPath + simulationName, i);
		//}

		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		int sampleTimeInit = clock(); /*INIT - SAMPLE TIME*/

		qRand = new NodeStar{ this->generateRandomNode() };
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Primeira tentativa de qNew: Vértices convexos
		if (vtree->getSize() > 0) {
			Point_2 pNear(qNear->getX(), qNear->getY());
			int idx = vtree->searchIndex(pNear, 1, 0);
			Point_2 nearestConvexVertice = vtree->getByIndex(idx);
			NodeStar* testNode = new NodeStar{ nearestConvexVertice.x(), nearestConvexVertice.y() };

			if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
				qNew = testNode;
				vtree->removeByIndex(idx);
				nodeEncountered = 1;
				generatedByVertice = true;
			}
		}

		//Segunda tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}

		//After here qRand is not more used!!
		delete qRand;

		int sampleTimeEnd = clock(); /*END - SAMPLE TIME*/
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock(); /*INIT - ADD NODE TIME*/
		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);

			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;

			this->rewire(nodeNeighborhood, qMin, qNew);

			NodeStar* qPathGoal = nullptr;
			NodeStar* lastAntecessor = nullptr;

			if (generatedByVertice) {
				if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					foundedNewPath = true;
				}
				generatedByVertice = false;
			} else {
				if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					foundedNewPath = true;
				}
			}

			double currentCost = 0;

			if (qGoal->getAntecessor()) {
				currentCost = ((NodeStar*)qGoal)->getCost();
			}

			if (foundedNewPath){
				qPathGoal = (NodeStar*)qGoal;
				vector<NodeStar*> originalPath = this->copyRoute((NodeStar*)qInit, (NodeStar*)qPathGoal);
				vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)getRoot(), (NodeStar*)qPathGoal);
				NodeStar* rGoal = routeNodes[0];
				NodeStar* rInit = routeNodes[1];
				//newCost = optimizePath(rInit, rGoal);*/
				newCost = currentCost;
				if (newCost < oldCost){
					Route* newRoute = new Route{ rInit, rGoal };
					newRoute->build();
					newRoute->setOriginalGoal(originalPath[0]);
					this->route = newRoute;
					oldCost = newCost;
					if (activatePrint) {
						displayTimeInit = clock(); /*INIT - DISPLAY TIME*/
						this->displayNow(folderPath + simulationName + "_founded_route_", i);
						displayTimeEnd = clock(); /*END - DISPLAY TIME*/
						activatePrint = false;
					}
				} else if (foundedNewPath) {
					this->removeNode(qNew, qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
					}
				}
				unoptimizedCost = qPathGoal->getCost();
				foundedNewPath = false;
			}
			//***FIM RRT-STAR***
		}

		int addNewNodeTimeEnd = clock(); /*INIT - ADD NODE TIME*/
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		addNewNodeTime = addNewNodeTime-((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		int init = clock(); /*INIT - DATA REPORT TIME*/
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		}else {
			cost = 0;
		}
		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes };
		//costsByIterationsOutputer->pushData(data, data + sizeOfData);

		if (accumulatedTime <= 0.1 && (accumulatedTime - nextTime) >= 0.0003) {
		//if (!this->goal->getAntecessor() && (this->qtdNodes - lastQtdNodes) > 0) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		} else if (accumulatedTime - nextTime >= (this->n / 100.0)) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			nextTime = accumulatedTime;
			imgCount++;
		}

		double displayTime = ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		int end = clock();  /*END - DATA REPORT TIME*/
		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC));// +displayTime; /*+ ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));*/
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	//Display to final time
	this->displayNow(folderPath + simulationName, imgCount);
	float data[] = { i, ((NodeStar*)(this->route->getGoal()))->getCost(), 0, accumulatedTime, this->qtdNodes };
	costsByIterationsOutputer->pushData(data, data + sizeOfData);

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	//this->displayNow(folderPath + simulationName, this->n);
}

void RRTStarSukharevVertices::buildSukharevVerticesKdTreeNoOpt(Node * qInit, Node * qGoal, double distanceToGenerateRoute, string envName, int cellsSukharev) {
	NodeStar* qRand;
	NodeStar* qNear;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max(), unoptimizedCost = 0;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/grid_compare/RRT_SV_NoOpt/";
	string simulationName = envName + "/rrtstar_sv_noopt_" + to_string(cellsSukharev) + "_grid_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };

	double planningTimeInit = clock();

	NodeStar* qInitStar = new NodeStar{ qInit };
	this->setRoot(qInitStar);
	this->stackNodes.push_back(qInitStar);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool generatedByVertice = false;
	bool activatePrint = false;

	vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();
	vector<Point_2*> vlist;

	for (int i = 0; i < obstacles.size(); i++) {
		vector<Point_2> obstacleVertices = obstacles[i]->getConvexVertices();
		for (int k = 0; k < obstacleVertices.size(); k++) {
			vlist.push_back(new Point_2{ obstacleVertices[k].x(), obstacleVertices[k].y() });
		}
	}

	KDTree* vtree = new KDTree(2, vlist.size());
	for (int i = 0; i < vlist.size(); i++) {
		vtree->insert(Point_2{vlist[i]->x(), vlist[i]->y()});
	}
	vtree->build();

	int i = 0;
	while (accumulatedTime <= n) {
	//for (int i = 1; i <= this->n; i++) {
		i++;
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		int sampleTimeInit = clock(); /*INIT - SAMPLE TIME*/

		qRand = new NodeStar{ this->generateRandomNode() };
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Primeira tentativa de qNew: Vértices convexos
		if (vtree->getSize() > 0) {
			Point_2 pNear(qNear->getX(), qNear->getY());
			int idx = vtree->searchIndex(pNear, 1, 0);
			Point_2 nearestConvexVertice = vtree->getByIndex(idx);
			NodeStar* testNode = new NodeStar{ nearestConvexVertice.x(), nearestConvexVertice.y() };

			if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
				qNew = testNode;
				vtree->removeByIndex(idx);
				nodeEncountered = 1;
				generatedByVertice = true;
			}
		}

		//Segunda tentativa de qNew: Grade de sukharev
		if (this->navigationSpace.getDispersionGrid().getGridSize() != 0 && nodeEncountered == 0) {
			NodeStar* qNewTemp;
			qNewTemp = this->createNewNodeBySukharevGrid(qNear, qRand);
			this->navigationSpace.putNodeInsideLimits(qNewTemp);
			int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
			delete qNewTemp;
			Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);
			if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
				qNewSukharev->visite();
				qNew = new NodeStar{ qNewSukharev->getX(),  qNewSukharev->getY() };
				nodeEncountered = 1;
			}
		}

		//Terceira tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}

		//After here qRand is not more used!!
		delete qRand;

		int sampleTimeEnd = clock(); /*END - SAMPLE TIME*/
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock(); /*INIT - ADD NODE TIME*/
		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);

			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;

			this->rewire(nodeNeighborhood, qMin, qNew);

			NodeStar* qPathGoal = nullptr;
			NodeStar* lastAntecessor = nullptr;

			if (generatedByVertice) {
				if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					foundedNewPath = true;
				}
				generatedByVertice = false;
			}
			else {
				if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					foundedNewPath = true;
				}
			}

			double currentCost = 0;

			if (qGoal->getAntecessor()) {
				currentCost = ((NodeStar*)qGoal)->getCost();
			}

			if (foundedNewPath) {
				qPathGoal = (NodeStar*)qGoal;
				vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)getRoot(), (NodeStar*)qPathGoal);
				NodeStar* rGoal = routeNodes[0];
				NodeStar* rInit = routeNodes[1];
				//newCost = optimizePath(rInit, rGoal);
				newCost = currentCost;
				if (newCost < oldCost) {
					Route* newRoute = new Route{ rInit, rGoal };
					newRoute->build();
					this->route = newRoute;
					oldCost = newCost;
					if (activatePrint) {
						displayTimeInit = clock(); /*INIT - DISPLAY TIME*/
						this->displayNow(folderPath + simulationName + "_founded_route_", i);
						displayTimeEnd = clock(); /*END - DISPLAY TIME*/
						activatePrint = false;
					}
				} else if (foundedNewPath) {
					this->removeNode(qNew, qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
					}
				}
				//unoptimizedCost = qPathGoal->getCost();
				foundedNewPath = false;
			}
			//***FIM RRT-STAR***
		}

		int addNewNodeTimeEnd = clock(); /*INIT - ADD NODE TIME*/
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		int init = clock(); /*INIT - DATA REPORT TIME*/
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		} else {
			cost = 0;
		}
		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes };
		costsByIterationsOutputer->pushData(data, data + sizeOfData);

		//double displayTime = ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		int end = clock();  /*END - DATA REPORT TIME*/
		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC)); // +displayTime;
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	//this->displayNow(folderPath + simulationName, this->n);
}

void RRTStarSukharevVertices::buildSukharevVerticesHough(Node * qInit, Node * qGoal, double distanceToGenerateRoute, string envName, int cellsSukharev) {
	NodeStar* qRand;
	NodeStar* qNear;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max(), unoptimizedCost = 0;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/RRT_SV/";
	string simulationName = envName + "/rrtstar_sv_transformed_test_" + to_string(cellsSukharev) + "_grid_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };

	double planningTimeInit = clock();

	this->setRoot(qInit);
	this->stackNodes.push_back(qInit);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool generatedByVertice = false;

	vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();

	//map<double, vector<Point_2>> vtable;
	vector<pair<double, Point_2*>> vtable;

	int count = 0;
	Point_2 originPoint = Point_2(this->navigationSpace.getInitialCoordinate()->getX(), this->navigationSpace.getInitialCoordinate()->getY());
	Point_2 endPoint = Point_2(this->navigationSpace.getFinalCoordinate()->getX(), this->navigationSpace.getFinalCoordinate()->getY());

	double deltaX = 50, deltaY = 1;
	for (int i = 0; i < obstacles.size(); i++) {
		vector<Point_2> obstacleVertices = obstacles[i]->getConvexVertices();
		cout << "//Obstacle " << i <<  endl;
		for (int k = 0; k < obstacleVertices.size(); k++) {
			count++;
			Point_2* v = new Point_2(obstacleVertices[k].x(), obstacleVertices[k].y());
			//cout << "list.push_back(P2(" << v->x() << "," << v->y() <<"));" << endl;
			//double d = MathUtils::euclidianDistancePoint(&originPoint, v);
			//double t = MathUtils::houghDistancePoint(&originPoint, &endPoint, v);
			double t = MathUtils::transformed(v, deltaX, deltaY);
			cout << "Transformed value V(" << v->x() << "," << v->y() << ") = " << t << endl;
			vtable.push_back(pair<double, Point_2*>(t, v));
		}
	}

	//ORDENA TABELA DE VÉRTICES
	if (vtable.size() > 0) {
		//boost::sort(vtable.begin(), vtable.end(), sortCompare);
		//boost::range::sort(vtable.begin(), vtable.end(), sortCompare);
		boost::sort::flat_stable_sort(vtable.begin(), vtable.end(), sortCompare);
	}

	availableVerticesSize = vtable.size();

	for (int i = 1; i <= this->n; i++) {
	/*	if (i % 500 == 0) {
			this->displayNow(folderPath + simulationName, i);
		}*/
		this->displayNow(folderPath + simulationName, i);

		//cout << "iteracao = " << i << " numero de elementos = " << this->qtdNodes << endl;
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		int sampleTimeInit = clock(); /*INIT - SAMPLE TIME*/

		qRand = new NodeStar{ this->generateRandomNode() };
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Primeira tentativa de qNew: Vértices convexos
		if(vtable.size() > 0){
			qNear->incrementTestsValue(1);
			int countVerticex = 0;
			//int sizeSearch = 30;
			int sizeSearch = 10;
			Point_2 qnearPoint = Point_2(qNear->getX(), qNear->getY());
			int pivot = findByProximity(qnearPoint, vtable, deltaX, deltaY);
			int selectedPivot = localSearch(&qnearPoint, vtable, sizeSearch, pivot);

			Point_2* testPoint = vtable[selectedPivot].second;
			NodeStar* testNode = new NodeStar{ testPoint->x(), testPoint->y() };
			cout << "Vertice mais próximo: T(" + to_string(vtable[selectedPivot].second->x()) + "," + to_string(vtable[selectedPivot].second->y()) + ") = " << vtable[selectedPivot].first << endl;

			if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
				qNew = testNode;
				nodeEncountered = 1;
				generatedByVertice = true;
				std::vector<pair<double, Point_2*>>::iterator vIt = vtable.begin() + selectedPivot;
				vtable.erase(vIt);
				vtable.shrink_to_fit();
			}

			////double dist = MathUtils::houghDistancePoint(&originPoint, &endPoint, &Point_2(qNear->getX(), qNear->getY()));
			//double dist = MathUtils::transformed(&Point_2(qNear->getX(), qNear->getY()), deltaX, deltaY);
			////std::multimap<double, Point_2>::iterator vIt = vtable.lower_bound(k);
			//std::vector<pair<double, Point_2*>>::iterator vIt = std::lower_bound(vtable.begin(), vtable.end(), pair<double, Point_2*>(dist,nullptr), sortCompare);
			//
			//if (vIt != vtable.begin()) {
			//	if (abs((*vIt).first - dist) > abs((*(vIt - 1)).first - dist)) {
			//		vIt--;
			//	}
			//}

			//std::vector<pair<double, Point_2*>>::iterator vItRight = vIt + 1;
			//std::vector<pair<double, Point_2*>>::iterator vItLeft = vIt - 1;

			//bool isBreak = false;

			////while (vItLeft >= vtable.begin() || vItRight <= vtable.end()){
			//	countVerticex++;				
			//	Point_2* testPoint = (*vIt).second;
			//	NodeStar* testNode = new NodeStar{ testPoint->x(), testPoint->y() };

			//	if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
			//		qNew = testNode;
			//		nodeEncountered = 1;
			//		generatedByVertice = true;
			//		vtable.erase(vIt);
			//		vtable.shrink_to_fit();
			//		//this->displayNow(folderPath + simulationName, i);
			//		
			//		isBreak = true;
			//		//cout << "Achou em " << countVerticex << "tentativas." << endl;
			//		//break;
			//	}

				//delete testNode;

				//CONTROLE DE VERIFICAÇÕES DE VÉRTICES
				//if (countVerticex >= qNear->getTestsValue()) {
			   /* if (countVerticex >= 10) {
					isBreak = true;
					break;
				}		*/		

				/*double distLeft = std::numeric_limits<double>::max(), distRight = std::numeric_limits<double>::max();

				if (vItLeft >= vtable.begin()) {
					distLeft = abs(dist - (*vItLeft).first);
				}

				if (vItRight <= vtable.end()) {
					distRight = abs(dist - (*vItRight).first);
				}

				if (distLeft <= distRight) {
					vIt = vItLeft;
					vItLeft = vIt -1;
				} else {
					vIt = vItRight;
					vItRight = vIt+1;
				}*/
			//}
		}

		//Segunda tentativa de qNew: Grade de sukharev
		if (this->navigationSpace.getDispersionGrid().getGridSize() != 0 && nodeEncountered == 0) {
			NodeStar* qNewTemp;
			qNewTemp = this->createNewNodeBySukharevGrid(qNear, qRand);
			this->navigationSpace.putNodeInsideLimits(qNewTemp);
			int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
			delete qNewTemp;
			//qNewTemp->~NodeStar();
			Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);
			if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
				qNewSukharev->visite();
				qNew = new NodeStar{ qNewSukharev->getX(),  qNewSukharev->getY() };
				//qNewSukharev->~Node();
				nodeEncountered = 1;
			}
		}

		//Terceira tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}

		//After here qRand is not more used!!
		delete qRand;

		int sampleTimeEnd = clock(); /*END - SAMPLE TIME*/
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock(); /*INIT - ADD NODE TIME*/
		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);

			/*	NodeStar* addedNode = this->searchInStackNodes(qNew);
			if (addedNode) {
			qNew = addedNode;
			this->insertNode(qMin, qNew);
			} else {*/
			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;
			//}

			//this->insertNode(qNear, qNew)
			this->rewire(nodeNeighborhood, qMin, qNew);

			NodeStar* qPathGoal = nullptr;
			NodeStar* lastAntecessor = nullptr;

			if (generatedByVertice) {
				if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					//qPathGoal = (NodeStar*)qGoal;
					foundedNewPath = true;
				}
				generatedByVertice = false;
			}
			else {
				if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					//qPathGoal = (NodeStar*)qGoal;
					foundedNewPath = true;
				}
			}

			double currentCost = 0;

			if (qGoal->getAntecessor()) {
				currentCost = ((NodeStar*)qGoal)->getCost();
			}

			if (foundedNewPath || (currentCost < unoptimizedCost)) {
				qPathGoal = (NodeStar*)qGoal;
				vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)qInit, (NodeStar*)qPathGoal);
				NodeStar* rGoal = routeNodes[0];
				NodeStar* rInit = routeNodes[1];
				newCost = optimizePath(rInit, rGoal);

				/*if (ceil(qGoal->getAntecessor()->getX()) == 988 && ceil(qGoal->getAntecessor()->getY()) == 978) {
				double x = qGoal->getAntecessor()->getAntecessor()->getAntecessor()->getX();
				double y = qGoal->getAntecessor()->getAntecessor()->getAntecessor()->getY();

				int a = 10;
				}
				*/
				if (newCost < oldCost) {
					//unoptimizedCost = qPathGoal->getCost();
					Route* newRoute = new Route{ rInit, rGoal };
					newRoute->build();
					this->route = newRoute;
					oldCost = newCost;
					displayTimeInit = clock(); /*INIT - DISPLAY TIME*/
					//this->displayNow(folderPath + simulationName + "_founded_route_", i);
					displayTimeEnd = clock(); /*END - DISPLAY TIME*/
				}
				else if (foundedNewPath) {
					this->removeNode(qNew, qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
						//((NodeStar*)qGoal)->updateCost();
					}
				}
				unoptimizedCost = qPathGoal->getCost();
				foundedNewPath = false;
			}
			//***FIM RRT-STAR***
		}

		int addNewNodeTimeEnd = clock(); /*INIT - ADD NODE TIME*/
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		int init = clock(); /*INIT - DATA REPORT TIME*/
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		}
		else {
			cost = 0;
		}
		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes };
		//float data[] = { i, cost, sampleTime, addNewNodeTime, accumulatedTime };
		costsByIterationsOutputer->pushData(data, data + sizeOfData);
		/*if (i % 250 == 0) {
		this->displayNow(folderPath + simulationName, i);
		}*/
		int end = clock();  /*END - DATA REPORT TIME*/

		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC)) + ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	this->displayNow(folderPath + simulationName, this->n);
}

void RRTStarSukharevVertices::buildSukharevVertices(Node * qInit, Node * qGoal, double distanceToGenerateRoute, string envName, int cellsSukharev) {
	NodeStar* qRand;
	NodeStar* qNear;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max(), unoptimizedCost = 0;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/RRT_SV/";
	string simulationName = envName + "/rrtstar_sv_" + to_string(cellsSukharev) + "_grid_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };

	double planningTimeInit = clock();

	//necessary to maintain the flag "startSample" equal true
	NodeStar* qInitStar = new NodeStar{ qInit };
	this->setRoot(qInitStar);
	this->stackNodes.push_back(qInitStar);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool generatedByVertice = false;

	vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();

	for (int i = 0; i < obstacles.size(); i++) {
		vector<Point_2> obstacleVertices = obstacles[i]->getConvexVertices();
		for (int k = 0; k < obstacleVertices.size(); k++) {
			availableVertices.push_back(Point_2(obstacleVertices[k].x(), obstacleVertices[k].y()));
		}
		//availableVertices.insert(availableVertices.end(), obstacleVertices.begin(), obstacleVertices.end());
	}

	availableVerticesSize = availableVertices.size();

	for (int i = 1; i <= this->n; i++) {
		//this->displayNow(folderPath + simulationName, i);
	/*	if (i % 500 == 0) {
			this->displayNow(folderPath + simulationName, i);
		}*/

		//cout << "iteracao = " <<  i << " numero de elementos = " << this->qtdNodes << endl;
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		int sampleTimeInit = clock(); /*INIT - SAMPLE TIME*/

		qRand = new NodeStar{ this->generateRandomNode() }; 
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Primeira tentativa de qNew: Vértices convexos
		{
			//qNear->incrementTestsValue(1);
			//int countVerticex = 0;

			//double lesserDist = std::numeric_limits<int>::max();
			//NodeStar* testNode = nullptr;

			//for (int it = 0; it < availableVerticesSize; it++) {
			//	countVerticex++;

			//	Point_2 nearestConvexVertice = availableVertices[it];
			//	NodeStar* nodeVertice = new NodeStar{nearestConvexVertice.x(), nearestConvexVertice.y()};
			//	double distance = MathUtils::euclidianDistanceNode(nodeVertice, qNear);

			//	if (lesserDist >= distance && this->collisionChecker.batchCollisionFreePath(qNear, nodeVertice)) {
			//		lesserDist = distance;
			//		testNode = nodeVertice;
			//	}

			//	if (countVerticex >= qNear->getTestsValue()) {
			//	//if (countVerticex >= 10) {
			//		break;
			//	}		
			//}

			//if (testNode) {
			//	//countVerticex++;
			//	qNew = testNode;
			//		
			//	for (int it = 0; it < availableVerticesSize; it++) {
			//		Point_2 vertice = availableVertices[it];						
			//		if (vertice.x() == testNode->getX() && vertice.y() == testNode->getY()) {								
			//			std::swap(availableVertices[it], availableVertices.at(availableVerticesSize - 1));
			//			availableVerticesSize--;							
			//			break;
			//		}
			//	}
			//	nodeEncountered = 1;
			//	generatedByVertice = true;
			//	//break;
			//}

			//delete testNode;

			//CONTROLE DE VERIFICAÇÕES DE VÉRTICES
			//if (countVerticex >= qNear->getTestsValue()) {
			////if (countVerticex >= 10) {
			//	//break;
			//}		

			vector<pair<int, Point_2*>> convexVertices = this->getConvexVerticesOrderedList(qNear);
			qNear->incrementTestsValue(1);
			int countVerticex = 0;

			for (const auto& pair : convexVertices) {
				Point_2 nearestConvexVertice = *(pair.second);
				//NodeStar* testNode = new NodeStar{ nearestConvexVertice.x().approx().inf(), nearestConvexVertice.y().approx().inf() };
				NodeStar* testNode = new NodeStar{ nearestConvexVertice.x(), nearestConvexVertice.y()};

				//nearestConvexVertice.~Point_2();
				//if (!qNear->isSucessorNode(testNode) || testNode->isAntecessor(qNear)){
				//if (!qNear->isSucessorNode(testNode) && !alreadyAddedVertice(nearestConvexVertice)){
				//if (!qNear->isSucessorNode(testNode)) {
					//if (!qNear->isSucessorNode(testNode) && !qNear->isAntecessor(testNode)){
				countVerticex++;
				//cout << "Pt " << i << "dist: " << MathUtils::euclidianDistanceNode(qNear, testNode) << endl;
				if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
					//addedVertices.push_back(nearestConvexVertice);

					qNew = testNode;

					//Testing deleted convex vertice
					//for (vector<Point_2>::iterator it = availableVertices.begin(); it < availableVertices.end(); it++) {
				/*	availableVertices.erase(std::remove(availableVertices.begin(), availableVertices.end(), nearestConvexVertice), availableVertices.end());
					availableVerticesSize--;
					break;*/
					for (int it = 0; it < availableVerticesSize; it++) {
						Point_2 vertice = availableVertices[it];
						//Point_2 vertice = *it;
						//if (to_double(vertice.x()) == testNode->getX() && to_double(vertice.y()) == testNode->getY()) {
						if (vertice.x() == testNode->getX() && vertice.y() == testNode->getY()) {
							//availableVertices.erase(it);
							//std::iter_swap(it, availableVertices.end() - (availableVertices.size() - availableVerticesSize));
							//pVector.erase(std::remove(pVector.begin(), pVector.end(), obj), pVector.end());
							std::swap(availableVertices[it], availableVertices.at(availableVerticesSize - 1));
							availableVerticesSize--;
							//std::remove(availableVertices.begin(), availableVertices.end(), vertice);
							//testNode->~NodeStar();
							break;
						}
					}
					nodeEncountered = 1;
					generatedByVertice = true;
					//testNode->~NodeStar();
					break;
				}
				//}

				delete testNode;
				//delete pair.second;

				//CONTROLE DE VERIFICAÇÕES DE VÉRTICES
				if (countVerticex >= qNear->getTestsValue()) {
				//if (countVerticex >= 10) {
					break;
				}

				break;
			}

			for (const auto& pair : convexVertices) {
				delete pair.second;
			}

			convexVertices.clear();
			convexVertices.shrink_to_fit();
		}

		//Segunda tentativa de qNew: Grade de sukharev
		if (this->navigationSpace.getDispersionGrid().getGridSize() != 0 && nodeEncountered == 0) {
			NodeStar* qNewTemp;
			qNewTemp = this->createNewNodeBySukharevGrid(qNear, qRand);
			this->navigationSpace.putNodeInsideLimits(qNewTemp);
			int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
			delete qNewTemp;
			//qNewTemp->~NodeStar();
			Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);
			if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
				qNewSukharev->visite();
				qNew = new NodeStar{ qNewSukharev->getX(),  qNewSukharev->getY()};
				//qNewSukharev->~Node();
				nodeEncountered = 1;
			}
		}

		//Terceira tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}
		
		//After here qRand is not more used!!
		delete qRand;

		int sampleTimeEnd = clock(); /*END - SAMPLE TIME*/
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock(); /*INIT - ADD NODE TIME*/
		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);
			
		/*	NodeStar* addedNode = this->searchInStackNodes(qNew);
			if (addedNode) {
				qNew = addedNode;
				this->insertNode(qMin, qNew);
			} else {*/
			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;
			//}

			//this->insertNode(qNear, qNew)
			this->rewire(nodeNeighborhood, qMin, qNew);

			NodeStar* qPathGoal = nullptr;
			NodeStar* lastAntecessor = nullptr;
		
			if (generatedByVertice) {
				if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					//qPathGoal = (NodeStar*)qGoal;
					foundedNewPath = true;
				}
				generatedByVertice = false;
			} else {
				if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					//qPathGoal = (NodeStar*)qGoal;
					foundedNewPath = true;
				}
			}

			double currentCost = 0;

			if(qGoal->getAntecessor()){
				currentCost = ((NodeStar*)qGoal)->getCost();
			}			
			
			if (foundedNewPath || (currentCost < unoptimizedCost)) {
				qPathGoal = (NodeStar*)qGoal;
				vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)getRoot(), (NodeStar*)qPathGoal);
				NodeStar* rGoal = routeNodes[0];
				NodeStar* rInit = routeNodes[1];
				newCost = optimizePath(rInit, rGoal);
				
	 			/*if (ceil(qGoal->getAntecessor()->getX()) == 988 && ceil(qGoal->getAntecessor()->getY()) == 978) {
					double x = qGoal->getAntecessor()->getAntecessor()->getAntecessor()->getX();
					double y = qGoal->getAntecessor()->getAntecessor()->getAntecessor()->getY();

					int a = 10;
				}
*/
				if (newCost < oldCost) {
					//unoptimizedCost = qPathGoal->getCost();
					Route* newRoute = new Route{ rInit, rGoal };
					newRoute->build();
					this->route = newRoute;
					oldCost = newCost;
					displayTimeInit = clock(); /*INIT - DISPLAY TIME*/
					//this->displayNow(folderPath + simulationName + "_founded_route_", i);
					displayTimeEnd = clock(); /*END - DISPLAY TIME*/
				} else if(foundedNewPath) {
					this->removeNode(qNew, qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
						//((NodeStar*)qGoal)->updateCost();
					}
				}
				unoptimizedCost = qPathGoal->getCost();
				foundedNewPath = false;
			}
			//***FIM RRT-STAR***
		}

		int addNewNodeTimeEnd = clock(); /*INIT - ADD NODE TIME*/
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		addNewNodeTime = addNewNodeTime;

		int init = clock(); /*INIT - DATA REPORT TIME*/
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		} else {
			cost = 0;
		}
		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes };
		//float data[] = { i, cost, sampleTime, addNewNodeTime, accumulatedTime };
		costsByIterationsOutputer->pushData(data, data + sizeOfData);
		/*if (i % 250 == 0) {
			this->displayNow(folderPath + simulationName, i);
		}*/
		double displayTime = ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		int end = clock();  /*END - DATA REPORT TIME*/
		
		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC)) + displayTime;
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	this->displayNow(folderPath + simulationName, this->n);
}

void RRTStarSukharevVertices::buildSukharevVerticesKdTree(Node * qInit, Node * qGoal, double distanceToGenerateRoute, string envName, int cellsSukharev) {
	NodeStar* qRand;
	NodeStar* qNear;
	bool activatePrint = false;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max(), unoptimizedCost = 0;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/RRT_SV/";
	string simulationName = envName + "/rrtstar_sv_kdtree_" + to_string(cellsSukharev) + "_grid_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };

	double planningTimeInit = clock();

	//necessary to maintain the flag "startSample" equal true
	NodeStar* qInitStar = new NodeStar{ qInit };
	this->setRoot(qInitStar);
	this->stackNodes.push_back(qInitStar);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool generatedByVertice = false;

	vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();
	vector<Point_2*> vlist;

	for (int i = 0; i < obstacles.size(); i++) {
		vector<Point_2> obstacleVertices;
		if (obstacles[i]->getOffSet()->size() > 0) {
			obstacleVertices = obstacles[i]->getOffSetConvexVertices();
		} else {
			obstacleVertices = obstacles[i]->getConvexVertices();
		}
		for (int k = 0; k < obstacleVertices.size(); k++) {
			vlist.push_back(new Point_2{ obstacleVertices[k].x(), obstacleVertices[k].y()});
		}
	}

	KDTree* vtree = new KDTree(2, vlist.size());
	for (int i = 0; i < vlist.size(); i++) {	
		//cout << vlist[i]->x()<< ", " << vlist[i]->y() << endl;
		vtree->insert(Point_2{ vlist[i]->x(), vlist[i]->y()});
	}
	vtree->build();

	//for (int i = 1; i <= this->n; i++) {
	int i = 0;
	int imgCount = 1; int lastQtdNodes = 0;
	double nextTime = 0;
	while (accumulatedTime <= this->n) {
		i++;
		/*if (nextTime <= accumulatedTime) {
			this->displayNow(folderPath + simulationName, nextTime);
			if (accumulatedTime == 0 || accumulatedTime/((double)this->n) < 0.03) {
				nextTime = accumulatedTime + (((double)this->n) / 80000.00);
			} else {
				nextTime = accumulatedTime + (((double)this->n) / 200.00);
			}
		}*/
	//int i = 1;
	//double optimalCost = 5214.94; //PHcurve: condição de parada para o teste.
	//double optimalCost = 5415.81; //com kappa  = 0.009

	//cout << "Optimal cost: " << optimalCost << endl; 

	//while (accumulatedTime <= this->n) {
		//this->displayNow(folderPath + simulationName, i);
		//if (this->getGoal()->getAntecessor()!= nullptr){
		//	//cout << "Current cost: " << this->getRoute()->getRouteCost() << endl; //PHcurve: condição de parada para o teste.
		//	if (this->getRoute()->getRouteCost() <= optimalCost+1) {
		//		//this->displayNow(folderPath + simulationName, i);
		//		//cout << "Optimal path reached !!!!" << endl; //PHcurve: condição de parada para o teste.
		//		break;
		//	}
		//}

		//cout << "iteracao = " <<  i << " numero de elementos = " << this->qtdNodes << endl;
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		//int sampleTimeInit = clock();
		auto sampleTimeInit = chrono::high_resolution_clock::now();

		qRand = new NodeStar{ this->generateRandomNode() };
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Primeira tentativa de qNew: Vértices convexos
		if(vtree->getSize() > 0){
			/*int k = 0;
			while (k <= qNear->getTestsValue()) {*/
				Point_2 pNear(qNear->getX(), qNear->getY());
				//cout << "TestValue: " << qNear->getTestsValue() << endl;
				//int idx = vtree->searchIndex(pNear, qNear->getTestsValue(), 0);
				int idx = vtree->searchIndex(pNear, 1, 0);
				//int idx = vtree->searchIndex(pNear, k+1, 0);
				//k++;
				Point_2 nearestConvexVertice = vtree->getByIndex(idx);
				NodeStar* testNode = new NodeStar{ nearestConvexVertice.x(), nearestConvexVertice.y() };
				
				/*if (qNear->getX() == 475 && qNear->getY() == 575) {
					if (testNode->getX() == 375 && testNode->getY() == 600) {
						cout << "Caramba!!" << endl;
						cout << "wow" << endl;
						int a = 10;
					}
				}*/
				//cout << "Pt " << i << "dist: " << MathUtils::euclidianDistanceNode(qNear, testNode) << endl;
				//if (!vtree->isCheckedByIndex(idx) && this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
				if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
					qNew = testNode;
					//qNew->incrementTestsValue(1);
					vtree->removeByIndex(idx);
					//vtree->checkByIndex(idx);
					nodeEncountered = 1;
					generatedByVertice = true;
					//break;
				}
				//qNear->incrementTestsValue(1);
			/*}
			qNear->incrementTestsValue(1);*/
		}

		//Segunda tentativa de qNew: Grade de sukharev
		if (this->navigationSpace.getDispersionGrid().getGridSize() != 0 && nodeEncountered == 0) {
			NodeStar* qNewTemp;
			qNewTemp = this->createNewNodeBySukharevGrid(qNear, qRand);
			this->navigationSpace.putNodeInsideLimits(qNewTemp);
			int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
			delete qNewTemp;
			Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);
			if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
				qNewSukharev->visite();
				qNew = new NodeStar{ qNewSukharev->getX(),  qNewSukharev->getY() };
				nodeEncountered = 1;
			}
		}

		//Terceira tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}

		//After here qRand is not more used!!
		delete qRand;

		//int sampleTimeEnd = clock();
		auto sampleTimeEnd = chrono::high_resolution_clock::now();

		//sampleTime = double(sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);
		sampleTime = chrono::duration_cast<chrono::nanoseconds>(sampleTimeEnd - sampleTimeInit).count()*1e-9;

		//int addNewNodeTimeInit = clock();
		auto addNewNodeTimeInit = chrono::high_resolution_clock::now();

		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);

			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;
		
			this->rewire(nodeNeighborhood, qMin, qNew);

			NodeStar* qPathGoal = nullptr;
			NodeStar* lastAntecessor = nullptr;

			if (generatedByVertice) {
				if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					foundedNewPath = true;
				}
				generatedByVertice = false;
			}
			else {
				if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					foundedNewPath = true;
				}
			}

			double currentCost = 0;

			if (qGoal->getAntecessor()) {
				currentCost = ((NodeStar*)qGoal)->getCost();
			}

			if (foundedNewPath || (currentCost < unoptimizedCost)) {
				qPathGoal = (NodeStar*)qGoal;
				vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)getRoot(), (NodeStar*)qPathGoal);
				NodeStar* rGoal = routeNodes[0];
				NodeStar* rInit = routeNodes[1];
				newCost = optimizePath(rInit, rGoal);

				if (newCost < oldCost) {
					Route* newRoute = new Route{ rInit, rGoal };
					newRoute->build();
					this->route = newRoute;
					oldCost = newCost;

					if (activatePrint) {
						displayTimeInit = clock();
						this->displayNow(folderPath + simulationName + "_founded_route_", i);
						displayTimeEnd = clock();
						activatePrint = false;
					}

					//displayTimeInit = clock(); /*INIT - DISPLAY TIME*/
					//this->displayNow(folderPath + simulationName + "_founded_route_", i);
					//displayTimeEnd = clock(); /*END - DISPLAY TIME*/
				} else if (foundedNewPath) {
					this->removeNode(qNew, qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
					}
				}
				unoptimizedCost = qPathGoal->getCost();
				foundedNewPath = false;
			}
			//***FIM RRT-STAR***
		}

		//int addNewNodeTimeEnd = clock();
		auto addNewNodeTimeEnd = chrono::high_resolution_clock::now();

		//double addNewNodeTime = double(addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		double addNewNodeTime = chrono::duration_cast<chrono::nanoseconds>(addNewNodeTimeEnd - addNewNodeTimeInit).count()*1e-9;

		addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		//addNewNodeTime = addNewNodeTime;

		int init = clock(); /*INIT - DATA REPORT TIME*/
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		}
		else {
			cost = 0;
		}
		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes }; 
		//i++;
		costsByIterationsOutputer->pushData(data, data + sizeOfData);
		//if (this->goal->getAntecessor() && (this->qtdNodes - lastQtdNodes) != 0){
		/*if (!this->goal->getAntecessor() && (this->qtdNodes - lastQtdNodes) >= 2  && (accumulatedTime - nextTime) > 0.0012) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		} else*/ 
		
		//if (accumulatedTime <= 0.03 && ((accumulatedTime - nextTime) >= 0.0008)) {
		/*if (accumulatedTime <= 0.0004 && ((accumulatedTime - nextTime) >= 0.000020)){
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		}	else if (accumulatedTime <= 0.015 && ((accumulatedTime - nextTime) >= 0.0003)) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		}	else if ((accumulatedTime - nextTime) >= 0.015) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			nextTime = accumulatedTime;
			imgCount++;
		}*/

		int end = clock();  /*END - DATA REPORT TIME*/
		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC));// +displayTime;
		////***FIM GERAÇÃO DE ESTATÍSTICAS***		
	}
	//Increment to count qGoal addition
	this->qtdNodes++;	

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	//this->displayNow(folderPath + simulationName, this->n);

	//Display to final time
	this->displayNow(folderPath + simulationName, imgCount);
	float data[] = { i, ((NodeStar*)(this->route->getGoal()))->getCost(), 0, accumulatedTime, this->qtdNodes };
	costsByIterationsOutputer->pushData(data, data + sizeOfData);
}

KDTree* RRTStarSukharevVertices::createKdTreeToPointSet(const int size, vector<Point_2> points) {

	KDTree* tree = new KDTree(2, points.size());
	for (int i = 0; i < points.size(); i++) {
		tree->insert(Point_2{ points[i].x(), points[i].y() });
	}

	tree->build();

	return tree;
}

void RRTStarSukharevVertices::buildSukharevVerticesProportion(Node * qInit, Node * qGoal, double distanceToGenerateRoute, string envName, int cellsSukharev) {
	NodeStar* qRand;
	NodeStar* qNear;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max(), unoptimizedCost = 0;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/RRT_SV/";
	string simulationName = envName + "/rrtstar_sv_proportion_test_" + to_string(cellsSukharev) + "_grid_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };

	double planningTimeInit = clock();

	//necessary to maintain the flag "startSample" equal true
	NodeStar* qInitStar = new NodeStar{ qInit };
	this->setRoot(qInitStar);
	this->stackNodes.push_back(qInitStar);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool generatedByVertice = false;

	vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();

	for (int i = 0; i < obstacles.size(); i++) {
		vector<Point_2> obstacleVertices = obstacles[i]->getConvexVertices();
		for (int k = 0; k < obstacleVertices.size(); k++) {
			availableVertices.push_back(Point_2(obstacleVertices[k].x(), obstacleVertices[k].y()));
		}
		//availableVertices.insert(availableVertices.end(), obstacleVertices.begin(), obstacleVertices.end());
	}

	availableVerticesSize = availableVertices.size();
	int originalVerticesQtd = availableVerticesSize;

	//std::srand(std::time(nullptr));

	//for (int i = 1; i <= this->n; i++) {
	int i = 0;
	while (accumulatedTime <= this->n) {
		i++;
		/*if (i % 500 == 0) {
			this->displayNow(folderPath + simulationName, i);
		}*/

		//cout << "iteracao = " <<  i << " numero de elementos = " << this->qtdNodes << endl;
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		int sampleTimeInit = clock(); /*INIT - SAMPLE TIME*/

		qRand = new NodeStar{ this->generateRandomNode() };
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		bool isActive = false;
		float proportion = availableVerticesSize / (double)originalVerticesQtd;
		//cout << originalVerticesQtd;
		if (proportion >= 0.50) {
			isActive = true;
		} else {
			float probability = (double)rand() / RAND_MAX;
			if (probability <= proportion) {
				isActive = true;
			}
		}

		//Primeira tentativa de qNew: Vértices convexos
		if(isActive){
			//qNear->incrementTestsValue(1);
			//int countVerticex = 0;

			//double lesserDist = std::numeric_limits<int>::max();
			//NodeStar* testNode = nullptr;

			//for (int it = 0; it < availableVerticesSize; it++) {
			//	countVerticex++;

			//	Point_2 nearestConvexVertice = availableVertices[it];
			//	NodeStar* nodeVertice = new NodeStar{nearestConvexVertice.x(), nearestConvexVertice.y()};
			//	double distance = MathUtils::euclidianDistanceNode(nodeVertice, qNear);

			//	if (lesserDist >= distance && this->collisionChecker.batchCollisionFreePath(qNear, nodeVertice)) {
			//		lesserDist = distance;
			//		testNode = nodeVertice;
			//	}

			//	if (countVerticex >= qNear->getTestsValue()) {
			//	//if (countVerticex >= 10) {
			//		break;
			//	}		
			//}

			//if (testNode) {
			//	//countVerticex++;
			//	qNew = testNode;
			//		
			//	for (int it = 0; it < availableVerticesSize; it++) {
			//		Point_2 vertice = availableVertices[it];						
			//		if (vertice.x() == testNode->getX() && vertice.y() == testNode->getY()) {								
			//			std::swap(availableVertices[it], availableVertices.at(availableVerticesSize - 1));
			//			availableVerticesSize--;							
			//			break;
			//		}
			//	}
			//	nodeEncountered = 1;
			//	generatedByVertice = true;
			//	//break;
			//}

			//delete testNode;

			//CONTROLE DE VERIFICAÇÕES DE VÉRTICES
			//if (countVerticex >= qNear->getTestsValue()) {
			////if (countVerticex >= 10) {
			//	//break;
			//}		

			vector<pair<int, Point_2*>> convexVertices = this->getConvexVerticesOrderedList(qNear);
			qNear->incrementTestsValue(1);
			int countVerticex = 0;

			for (const auto& pair : convexVertices) {
				Point_2 nearestConvexVertice = *(pair.second);
				//NodeStar* testNode = new NodeStar{ nearestConvexVertice.x().approx().inf(), nearestConvexVertice.y().approx().inf() };
				NodeStar* testNode = new NodeStar{ nearestConvexVertice.x(), nearestConvexVertice.y() };

				//nearestConvexVertice.~Point_2();
				//if (!qNear->isSucessorNode(testNode) || testNode->isAntecessor(qNear)){
				//if (!qNear->isSucessorNode(testNode) && !alreadyAddedVertice(nearestConvexVertice)){
				//if (!qNear->isSucessorNode(testNode)) {
				//if (!qNear->isSucessorNode(testNode) && !qNear->isAntecessor(testNode)){
				countVerticex++;
				if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
					//addedVertices.push_back(nearestConvexVertice);

					qNew = testNode;

					//Testing deleted convex vertice
					//for (vector<Point_2>::iterator it = availableVertices.begin(); it < availableVertices.end(); it++) {
					/*	availableVertices.erase(std::remove(availableVertices.begin(), availableVertices.end(), nearestConvexVertice), availableVertices.end());
					availableVerticesSize--;
					break;*/
					for (int it = 0; it < availableVerticesSize; it++) {
						Point_2 vertice = availableVertices[it];
						//Point_2 vertice = *it;
						//if (to_double(vertice.x()) == testNode->getX() && to_double(vertice.y()) == testNode->getY()) {
						if (vertice.x() == testNode->getX() && vertice.y() == testNode->getY()) {
							//availableVertices.erase(it);
							//std::iter_swap(it, availableVertices.end() - (availableVertices.size() - availableVerticesSize));
							//pVector.erase(std::remove(pVector.begin(), pVector.end(), obj), pVector.end());
							std::swap(availableVertices[it], availableVertices.at(availableVerticesSize - 1));
							availableVerticesSize--;
							//std::remove(availableVertices.begin(), availableVertices.end(), vertice);
							//testNode->~NodeStar();
							break;
						}
					}
					nodeEncountered = 1;
					generatedByVertice = true;
					//testNode->~NodeStar();
					break;
				}
				//}

				delete testNode;
				//delete pair.second;

				//CONTROLE DE VERIFICAÇÕES DE VÉRTICES
				if (countVerticex >= qNear->getTestsValue()) {
					//if (countVerticex >= 10) {
					break;
				}
			}

			for (const auto& pair : convexVertices) {
				delete pair.second;
			}

			convexVertices.clear();
			convexVertices.shrink_to_fit();
		}

		//Segunda tentativa de qNew: Grade de sukharev
		if (this->navigationSpace.getDispersionGrid().getGridSize() != 0 && nodeEncountered == 0) {
			NodeStar* qNewTemp;
			qNewTemp = this->createNewNodeBySukharevGrid(qNear, qRand);
			this->navigationSpace.putNodeInsideLimits(qNewTemp);
			int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
			delete qNewTemp;
			//qNewTemp->~NodeStar();
			Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);
			if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
				qNewSukharev->visite();
				qNew = new NodeStar{ qNewSukharev->getX(),  qNewSukharev->getY() };
				//qNewSukharev->~Node();
				nodeEncountered = 1;
			}
		}

		//Terceira tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}

		//After here qRand is not more used!!
		delete qRand;

		int sampleTimeEnd = clock(); /*END - SAMPLE TIME*/
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock(); /*INIT - ADD NODE TIME*/
		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);

			/*	NodeStar* addedNode = this->searchInStackNodes(qNew);
			if (addedNode) {
			qNew = addedNode;
			this->insertNode(qMin, qNew);
			} else {*/
			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;
			//}

			//this->insertNode(qNear, qNew)
			this->rewire(nodeNeighborhood, qMin, qNew);

			NodeStar* qPathGoal = nullptr;
			NodeStar* lastAntecessor = nullptr;

			if (generatedByVertice) {
				if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					//qPathGoal = (NodeStar*)qGoal;
					foundedNewPath = true;
				}
				generatedByVertice = false;
			} else {
				if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					lastAntecessor = (NodeStar*)qGoal->getAntecessor();
					if (lastAntecessor) {
						this->removeNode(lastAntecessor, qGoal);
					}
					this->insertNode(qNew, (NodeStar*)qGoal);
					//qPathGoal = (NodeStar*)qGoal;
					foundedNewPath = true;
				}
			}

			double currentCost = 0;

			if (qGoal->getAntecessor()) {
				currentCost = ((NodeStar*)qGoal)->getCost();
			}

			if (foundedNewPath || (currentCost < unoptimizedCost)) {
				qPathGoal = (NodeStar*)qGoal;
				vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)getRoot(), (NodeStar*)qPathGoal);
				NodeStar* rGoal = routeNodes[0];
				NodeStar* rInit = routeNodes[1];
				newCost = optimizePath(rInit, rGoal);

				/*if (ceil(qGoal->getAntecessor()->getX()) == 988 && ceil(qGoal->getAntecessor()->getY()) == 978) {
				double x = qGoal->getAntecessor()->getAntecessor()->getAntecessor()->getX();
				double y = qGoal->getAntecessor()->getAntecessor()->getAntecessor()->getY();

				int a = 10;
				}
				*/
				if (newCost < oldCost) {
					//unoptimizedCost = qPathGoal->getCost();
					Route* newRoute = new Route{ rInit, rGoal };
					newRoute->build();
					this->route = newRoute;
					oldCost = newCost;
					displayTimeInit = clock(); /*INIT - DISPLAY TIME*/
					//this->displayNow(folderPath + simulationName + "_founded_route_", i);
					displayTimeEnd = clock(); /*END - DISPLAY TIME*/
				}else if (foundedNewPath) {
					this->removeNode(qNew, qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
						//((NodeStar*)qGoal)->updateCost();
					}
				}
				unoptimizedCost = qPathGoal->getCost();
				foundedNewPath = false;
			}
			//***FIM RRT-STAR***
		}

		int addNewNodeTimeEnd = clock(); /*INIT - ADD NODE TIME*/
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		//addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		int init = clock(); /*INIT - DATA REPORT TIME*/
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		} else {
			cost = 0;
		}
		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes };
		//float data[] = { i, cost, sampleTime, addNewNodeTime, accumulatedTime };
		costsByIterationsOutputer->pushData(data, data + sizeOfData);
		/*if (i % 250 == 0) {
		this->displayNow(folderPath + simulationName, i);
		}*/
		double displayTime = ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		int end = clock();  /*END - DATA REPORT TIME*/

		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC)) + displayTime;
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}

	//Increment to count qGoal addition
	this->qtdNodes++;

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	this->displayNow(folderPath + simulationName, 0);
}

vector<Point_2> RRTStarSukharevVertices::getConvexHull(){
	return this->convexHull;
}

vector<vector<Point_2>> RRTStarSukharevVertices::getObstacleConvexHulls(){
	return this->obstacleConvexHulls;
}

int RRTStarSukharevVertices::findByProximity(Point_2& v, vector<pair<double, Point_2*>>& vtable, double deltaX, double deltaY) {
	if (vtable.size() > 0) {
		double dist = MathUtils::transformed(&v, deltaX, deltaY);
		cout << "Transformed value V(" << v.x() << "," << v.y() << ") = " << dist << endl;
		vector<pair<double, Point_2*>>::iterator vIt = std::lower_bound(vtable.begin(), vtable.end(), pair<double, Point_2*>(dist, nullptr), sortCompare);
		if (vIt != vtable.begin()) {
			if (abs((*vIt).first - dist) > abs((*(vIt - 1)).first - dist)) {
				vIt--;
			}
		}

		return vIt - vtable.begin();
	}
}

int RRTStarSukharevVertices::localSearch(Point_2* p, vector<pair<double, Point_2*>> vtable, int neighborhoodSize, int pivot) {
	int leftPivot = pivot, rightPivot = pivot;
	int stepLeft = pivot - 1;
	double smallerDistLeft = MathUtils::euclidianDistancePoint(p, vtable[pivot].second);
	while ((stepLeft >= (pivot - neighborhoodSize)) && ((stepLeft) >= 0)) {
		double distTrans = MathUtils::euclidianDistancePoint(p, vtable[stepLeft].second);
		if (smallerDistLeft > distTrans) {
			smallerDistLeft = distTrans;
			leftPivot = stepLeft;
		}

		stepLeft--;
	}

	int stepRight = pivot + 1;
	double smallerDistRight = MathUtils::euclidianDistancePoint(p, vtable[pivot].second);
	while ((stepRight <= (pivot + neighborhoodSize)) && ((stepRight) < vtable.size())) {
		double distTrans = MathUtils::euclidianDistancePoint(p, vtable[stepRight].second);
		if (smallerDistRight > distTrans) {
			smallerDistRight = distTrans;
			rightPivot = stepRight;
		}
		stepRight++;
	}

	if (smallerDistRight <= smallerDistLeft) {
		return rightPivot;
	} else {
		return leftPivot;
	}
}

vector<pair<int, Point_2*>> RRTStarSukharevVertices::getConvexVerticesOrderedList(NodeStar* qNear) {
	/*vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();
	double minimalDistanceToObstacle = std::numeric_limits<double>::max();
	Point_2 nearestVertice = Point_2(-1, -1);
	vector<pair<double, Point_2>> orderedVertice;
	
	for (int i = 0; i < obstacles.size(); i++) {
		vector<Point_2> convexVertices = obstacles[i]->getConvexVertices();
		for (int verticeIt = 0; verticeIt < convexVertices.size(); verticeIt++) {
			Point_2* vertice = &convexVertices[verticeIt];
			double x = vertice->x().approx().inf();
			double y = vertice->y().approx().inf();

			NodeStar nodeVertice = NodeStar{ x, y };
			if (qNear->getX() != nodeVertice.getX() || qNear->getY() != nodeVertice.getY()) {
				double distance = MathUtils::euclidianDistanceNode(&nodeVertice, qNear);
				orderedVertice.push_back(pair<double, Point_2>(distance, *vertice));
			}
		}
	}
	
	std:sort(orderedVertice.begin(), orderedVertice.end());
	return orderedVertice;*/

	double minimalDistanceToObstacle = std::numeric_limits<int>::max();
	vector<pair<int, Point_2*>> orderedVertice;

	for (int verticeIt = 0; verticeIt < availableVerticesSize; verticeIt++) {
		double x = availableVertices[verticeIt].x();
		double y = availableVertices[verticeIt].y();

		Point_2* vertice = new Point_2{x,y};
		NodeStar* nodeVertice = new NodeStar{ x, y };

		if (qNear->getX() != nodeVertice->getX() || qNear->getY() != nodeVertice->getY()) {
			double distance = MathUtils::euclidianDistanceNode(nodeVertice, qNear);
			orderedVertice.push_back(pair<int, Point_2*>((int)distance, vertice));			
		}
		delete nodeVertice;
	}

	//std:sort(orderedVertice.begin(), orderedVertice.end(), std::less_equal<pair<int, Point_2*>>());
	//std:stable_sort(orderedVertice.begin(), orderedVertice.end(), sortCompare);

	//boost::sort::spreadsort::float_sort(orderedVertice.begin(), orderedVertice.end());
	if (orderedVertice.size() > 0) {
		boost::sort::flat_stable_sort(orderedVertice.begin(), orderedVertice.end(), sortCompare);
	}
 	return orderedVertice;
}

bool RRTStarSukharevVertices::collisionCheckedVertice(vector<Point_2>* checkedVertices, Point_2 vertice) {
	for (int i = 0; i < checkedVertices->size(); i++) {
		if (vertice == (*checkedVertices)[i]) {
			return true;
		}
	}
	return false;
}

vector<NodeStar*> RRTStarSukharevVertices::getNearestFreeCollisionVertices(NodeStar * node){
	vector<StaticObstacle*> obstacles = this->navigationSpace.getStaticObstacles();
	vector<NodeStar*>  visibleVertices;
	double lesserDistance = std::numeric_limits<double>::max();
	for (int i = 0; i < obstacles.size(); i++) {
		const vector<Point_2> convexVertices(obstacles[i]->getConvexVertices());
		for (int verticeIt = 0; verticeIt < convexVertices.size(); verticeIt++) {
			Point_2 vertice = convexVertices[verticeIt];
			/*double x = to_double(vertice.x());
			double y = to_double(vertice.y());*/
			double x = vertice.x();
			double y = vertice.y();

			NodeStar* nodeVertice = new NodeStar{ x, y };
			if (this->collisionChecker.batchCollisionFreePath(nodeVertice, node)) {
				visibleVertices.push_back(nodeVertice);
			}
		}
	}
	return visibleVertices;
}

bool RRTStarSukharevVertices::isInList(vector<NodeStar*> list, NodeStar* node) {
	for (int i = 0; i < list.size(); i++) {
		if (list[i]->getX() == node->getX() && list[i]->getY() == node->getY()) {
			return true;
		}
	}
	return false;
}

bool RRTStarSukharevVertices::alreadyAddedVertice(Point_2 vertice) {
	//for (int i = 0; i < addedVertices.size(); i++) {
	//	//if (to_double(vertice.x()) == to_double(addedVertices[i].x()) && to_double(vertice.y()) == to_double(addedVertices[i].y())) {
	//	if (vertice.x() == addedVertices[i].x() && vertice.y() == addedVertices[i].y()) {
	//		return true;
	//	}
	//}
	return false;
}

NodeStar* RRTStarSukharevVertices::generateBiasedNode(){
	std::random_device rd;
	std::mt19937 generator(rd());

	//Seleciona dos obstáculos aleatoriamente
	int qtyObstacles = this->navigationSpace.getStaticObstacles().size();
	std::uniform_int_distribution<> selectObstacle(0, qtyObstacles - 1);
	int randomObstacle = selectObstacle(generator);
	StaticObstacle* obstacle = this->navigationSpace.getStaticObstacles().at(randomObstacle);

	//Seleciona um dos vértices da célula aleatoriamente
	int qtyVertex = obstacle->getShape()->size();
	std::uniform_int_distribution<> selectVertex(0, qtyVertex - 1);
	int randomVertex = selectVertex(generator);
	const Point_2 vertex = obstacle->getShape()->vertex(randomVertex);

	//NodeStar* randomNode = new NodeStar(to_double(vertex.x()), to_double(vertex.y()));
	NodeStar* randomNode = new NodeStar(vertex.x(), vertex.y());

	return randomNode;
}

NodeStar* RRTStarSukharevVertices::createNewNodeBySukharevGrid(Node* qNear, Node* qRand) {
	NodeStar* qNew;
	
	/*if (qNear->getX() == qNear->getY()) {
		qNew = new NodeStar{ qNear};*/
	double sideCellX = 2*this->navigationSpace.getDispersionGrid().getStepCentroidPositionLat();
	double sideCellY = 2 * this->navigationSpace.getDispersionGrid().getStepCentroidPositionLong();
	//cout << sideCellX << " ; " << sideCellY;
	double deltaQ = std::sqrt(pow(sideCellX, 2) + pow(sideCellY, 2));

	double qNearX = qNear->getNodeWaypoint()->getLatitude(), qNearY = qNear->getNodeWaypoint()->getLongitude();
	double qRandX = qRand->getNodeWaypoint()->getLatitude(), qRandY = qRand->getNodeWaypoint()->getLongitude();

	double hipotenusa, deltaQLat, deltaQLong, porcentagemDeltaQ, catetoSin, catetoCos, senoTeta, cosTeta, vetorULat, vetorULong;

	hipotenusa = MathUtils::euclidianDistanceNode(qNear, qRand);

	catetoCos = qRandX - qNearX;
	catetoSin = qRandY - qNearY;

	cosTeta = catetoCos / hipotenusa;
	vetorULat = qNear->getNodeWaypoint()->getLatitude() + (cosTeta)*deltaQ;
	senoTeta = catetoSin / hipotenusa;
	vetorULong = qNear->getNodeWaypoint()->getLongitude() + (senoTeta)*deltaQ;

	qNew = new NodeStar{ vetorULat, vetorULong };
	
	return qNew;
}

double RRTStarSukharevVertices::optimizePath(NodeStar* qInit, NodeStar* qGoal) {
	NodeStar* qCurrent = qGoal;
	NodeStar* qVisibilityCheck = (NodeStar*)qGoal;

	while (qVisibilityCheck != qInit) {
		if (!qVisibilityCheck->getAntecessor()->getAntecessor()) {
			qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
			qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);
		} else {
			if (!collisionChecker.batchCollisionFreePath(qCurrent, qVisibilityCheck->getAntecessor()->getAntecessor())) {
				qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
				qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);
				qCurrent = (NodeStar*)qCurrent->getAntecessor();
			}
		}		
		qVisibilityCheck = (NodeStar*)qVisibilityCheck->getAntecessor();
	}

	//this->updatePathNodesCost(qInit, qGoal);
	return qGoal->getCost();
}

void RRTStarSukharevVertices::updatePathNodesCost(NodeStar* qInit, NodeStar* qGoal) {
	NodeStar* qCurrent = qGoal;
	while (qCurrent != qInit) {
		qCurrent->updateCost();
		qCurrent = (NodeStar*)qCurrent->getAntecessor();
	}
}

NodeStar* RRTStarSukharevVertices::searchInStackNodes(NodeStar* nodeToSearch) {
	for (int i = 0; i < stackNodes.size(); i++) {
		if (stackNodes[i]->getX() == nodeToSearch->getX() && stackNodes[i]->getY() == nodeToSearch->getY()) {
			return (NodeStar*)stackNodes[i];
		}
	}
	return nullptr;
}

//BACKUP DO BUILD DA RRT*-SUKHAREVVERTICES
void RRTStarSukharevVertices::build(Node * qInit, Node * qGoal, double distanceToGenerateRoute, string envName, int cellsSukharev) {
	NodeStar* qRand;
	NodeStar* qNear;
	vector<NodeStar*> nodeNeighborhood;
	double newCost, oldCost = std::numeric_limits<double>::max();
	this->setRoot(qInit);
	this->stackNodes.push_back(qInit);
	this->qtdNodes++;

	double planningTimeInit = clock();
	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string fileByIteractionName = "C:/RRTSimulations/byIteration/rrtstar_sv_" + to_string(cellsSukharev) + "grid_byIteration_" + envName + "_" + to_string(seed) + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };
	int s = 0, i = 0;
	//while (s == 0) {

	int nearestVerticeTimeInit = clock();
	//vector<NodeStar*> qKeys = this->getNearestFreeCollisionVertices((NodeStar*)qGoal);
	int nearestVerticeTimeEnd = clock();
	double nearestVerticeTime = (nearestVerticeTimeEnd - nearestVerticeTimeInit) / double(CLOCKS_PER_SEC);

	double accumulatedTime = 0, timeDataReport = 0;
	accumulatedTime += nearestVerticeTime;

	for (int i = 0; i <= this->n; i++) {
		double sampleTime = 0;
		int sampleTimeInit = clock();
		//cout << "iteracao = " << i << " numero de elementos = " << this->qtdNodes << endl;	//i++;
		qRand = new NodeStar{ this->generateRandomNode() }; qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Vector of nodes to test in batchCollisionCheck
		//int g_begin = clock();
		//Primeira tentativa de qNew: Vértices convexos
		//Point_2 nearestConvexVertice = this->findNearestConvexVertice(qNear);
		//vector<pair<double, Point_2>> convexVertices = this->getConvexVerticesOrderedList(qNear);
		////if (nearestConvexVertice.x().approx().inf() >= 0 && nearestConvexVertice.y().approx().inf() >= 0) {
		//qNear->incrementTestsValue(1);
		//int countVerticex = 0;
		//for (const auto& pair : convexVertices) {
		//	Point_2 nearestConvexVertice = pair.second;
		//	NodeStar* testNode = new NodeStar{ nearestConvexVertice.x().approx().inf(), nearestConvexVertice.y().approx().inf() };
		//	//if (!qNear->isSucessorNode(testNode) || testNode->isAntecessor(qNear)){
		//	if (!qNear->isSucessorNode(testNode)){
		//		countVerticex++;
		////	if (!qNear->isSucessorNode(testNode) && !qNear->isInRoute(testNode) && !testNode->isAntecessor(qNear)){
		//		if (this->collisionChecker.batchCollisionFreePath(qNear, testNode)) {
		//			qNew = testNode;
		//			nodeEncountered = 1;
		//			break;
		//		}
		//	}
		//	if (countVerticex >= qNear->getTestsValue()) {
		//		break;
		//	}
		//}
		//cout << "Vertices testados: " << countVerticex << endl;
		//convexVertices.~vector();

		//Point_2 nearestConvexVertice;
		//vector<Point_2>* testedCollisionVertices = new vector<Point_2>();	
		//while (nodeEncountered != 1) {
		//	nearestConvexVertice = this->findNearestConvexVertice(qNear, testedCollisionVertices);
		//	//NodeStar* nearestConvexVertice = nullptr;			
		//	//if (nearestConvexVertice != nullptr) {
		//	if (nearestConvexVertice.x().approx().inf() >= 0 && nearestConvexVertice.y().approx().inf() >= 0) {
		//		qNew = new NodeStar{ nearestConvexVertice.x().approx().inf(), nearestConvexVertice.y().approx().inf() };
		//		if (collisionChecker.batchCollisionFreePath(nodes, qNew)) {
		//			//qNew = nearestConvexVertice;
		//			nodeEncountered = 1;
		//			//this->collisionChecker.insertInColisionFreePointSet(qNew, 0);
		//			this->addedVertices.push_back(nearestConvexVertice);
		//		} else {
		//			testedCollisionVertices->push_back(nearestConvexVertice);
		//		}
		//	} else {
		//		break;
		//	}
		//}

		//int pt1_end = clock();
		//cout << "Tempo 1: " << (pt1_end - pt1_begin) / double(CLOCKS_PER_SEC) << "\t";

		//Segunda tentativa de qNew: Grade de sukharev
		//int pt2_begin = clock();
		if (nodeEncountered == 0) {
			NodeStar* qNewTemp;
			qNewTemp = this->createNewNodeBySukharevGrid(qNear, qRand);
			this->navigationSpace.putNodeInsideLimits(qNewTemp);
			int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
			Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);

			/*	if (qNewSukharev != nullptr && collisionChecker.collisionFreePoint(qNewSukharev)) {*/
			/*	vector<Node*> nodes;
			nodes.push_back(qNear);*/
			//if (collisionChecker.batchCollisionFreePath(nodes, qNewSukharev)) {			
			if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
				qNewSukharev->visite();
				qNew = new NodeStar{ qNewSukharev };
				nodeEncountered = 1;
			}
			//nodes.~vector();

		}
		//int pt2_end = clock();
		//cout << "Tempo 2: " << (pt2_end - pt2_begin) / double(CLOCKS_PER_SEC) << "\t";

		//Terceira tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		//int pt3_begin = clock();
		if (nodeEncountered == 0) {
			qNew = this->createNewNodeStar(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}
		//int pt3_end = clock();
		//cout << "Tempo 3: " << (pt3_end - pt3_begin) / double(CLOCKS_PER_SEC) << endl;

		int sampleTimeEnd = clock();
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock();
		if (qNew != nullptr && nodeEncountered == 1) {
			//***INICIO RRT-STAR**
			nodeNeighborhood = this->getNeighborsInRadius(qNew);
			NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);
			this->insertNode(qMin, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;
			this->rewire(nodeNeighborhood, qMin, qNew);

			/*	this->insertNode(qNear, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;*/

			NodeStar* qPathGoal = nullptr;
			NodeStar* lastAntecessor = nullptr;
			//if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
			//if ((qKey->getX() == qNew->getX() && qKey->getY() == qNew->getY())) {
			//if (isInList(qKeys, qNew)) {
			if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
				lastAntecessor = (NodeStar*)qGoal->getAntecessor();
				if (lastAntecessor) {
					this->removeNode(lastAntecessor, qGoal);
				}
				this->insertNode(qNew, (NodeStar*)qGoal);
				qPathGoal = (NodeStar*)qGoal;
				//this->goal = qPathGoal; //Lembrar de tirar isso aqui
			}

			if (qPathGoal) {
				newCost = optimizePath((NodeStar*)qInit, (NodeStar*)qPathGoal);
				//newCost = qPathGoal->getCost();
				if (newCost < oldCost) {
					this->goal = qPathGoal;
					oldCost = newCost;
					//s = 1;
				}
				else {
					this->removeNode(qNew, qGoal);
					//this->removeSucessor(qGoal);
					if (lastAntecessor) {
						this->insertNode(lastAntecessor, (NodeStar*)qGoal);
						((NodeStar*)qGoal)->updateCost();
					}
				}
			}
			//***FIM RRT-STAR***

			/*this->insertNode(qNear, qNew);
			this->qtdNodes++;

			if (MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) {
			vector<Node*> nodes;
			nodes.push_back(qNew);
			if (collisionChecker.batchCollisionFreePath(nodes, qGoal)) {
			this->insertNode(qNew, qGoal);
			this->goal = qGoal;
			s = 1;
			}
			nodes.~vector();
			}*/
		}
		int addNewNodeTimeEnd = clock();
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);

		int init = clock();
		accumulatedTime += (sampleTime + addNewNodeTime);
		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		float data[] = { i, ((NodeStar*)this->goal)->getCost(), sampleTime, accumulatedTime, this->qtdNodes };
		//float data[] = {i, newCost, sampleTime, accumulatedTime, this->qtdNodes};
		costsByIterationsOutputer->pushData(data, data + sizeOfData);
		int end = clock();
		timeDataReport += (end - init) / double(CLOCKS_PER_SEC);
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	//int stop_s = clock();
	//cout << "Tempo de build: " << this->planningTime << endl;
	//cout << "Custo: da rota: " << ((NodeStar*)this->goal)->getCost() << endl;*/
	//cin;
}