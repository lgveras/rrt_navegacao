#include "RRTStar.h"
#include "MathUtils.h"
#include "ResultOutputer.h"
#include <iostream>
//#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
//#include <CGAL/intersections.h>
//#include <CGAL/enum.h>
#include <algorithm>

//typedef CGAL::Exact_predicates_exact_constructions_kernel K;
//typedef K::Circle_2 Circle_2;
//typedef K::Point_2 Point_2;
//typedef K::Intersect_2 Intersect_2;

using namespace std;

Node* currentQNew;

RRTStar::~RRTStar(){
}

RRTStar::RRTStar(NavigationEnvironment ne, const double r, int const n) : RRT(ne, n), radiusNeighborhood(r){
	//this->collisionChecker = BialkowskiCollisionChecker{ &(this->navigationSpace) };
}

//
//void RRTStar::build(Node* qInit, Node *qGoal, double distanceToGenerateRoute){
//	Node* qRand;
//	Node* qNear;
//	int i = 0;
//	int s = 0;
//
//	//Substitui os nós normais por nós do tipo Star
//	qInit = new NodeStar{ qInit };
//	qGoal = new NodeStar{ qGoal };
//
//	// ALGORITMO RRT - LINHA 1: inserir q_init na arvore RRT
//	this->setRoot(qInit);
//	//pilha para busca do mais próximo
//	this->stackNodes.push_back(qInit);
//
//	// ALGORITMO RRT - LINHA 2: s recebe zero
//	// ALGORITMO RRT - LINHA 3: enquanto s for igual a zero faca
//	int start_s = clock();
//
//	while (s == 0) {
//		int begin_t = clock();
//		cout << "iteracao = " << i << " numero de elementos = " << this->qtdNodes << endl;
//
//		// ALGORITMO RRT - LINHA 4: q_rand recebe RAND_CONFIG(C)
//		qRand = this->generateRandomNode();
//
//		// ALGORITMO RRT - LINHA 5: q_near recebe NEAREST_VERTEX(q_rand,G)
//		qNear = this->nearestNode(qRand);
//
//		// ALGORITMO RRT - LINHA 6: q_new recebe NEW_CONF(q_near, delta_q)
//		// ALGORITMO RRT - LINHA 7: se o segmento de reta (q_near,q_new) nao intercepta qualquer obstaculo faca
//		NodeStar* qNew = this->createNewNodeStar(qNear, qRand);
//
//		if (qNew != NULL) {
//			if (collisionChecker.collisionFreePoint(qNew)) {
//				//Linha 4 algoritmo RRTStar
//				vector<Node*> nodes;
//				nodes.push_back(qNear);
//				if (collisionChecker.batchCollisionFreePath(nodes, qNew)) {
//					// ALGORITMO RRT - LINHA 8: inserir o no q_new na arvore G
//					// ALGORITMO RRT - LINHA 9: inserir a aresta que une q_near a q_new na arvore G
//					// ALGORITMO RRT - LINHA 10: antecessor(q_new) recebe q_near
//					this->insertNode(qNear, qNew);
//
//					//pilha para busca do mais próximo
//					this->stackNodes.push_back(qNew);
//
//					//Extende usando as regras da RRTStar
//					this->extend(qNear, qNew);
//
//					if (MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute){
//						vector<Node*> nodes;
//						nodes.push_back(qNew);
//						if (collisionChecker.batchCollisionFreePath(nodes, qGoal)) {
//							//qNew já foi adicionado, agora é o último ponto da arvore
//							//se passou por esse if, é porque qGol deve ser adicionado como novo ponto
//							this->insertNode(qNew, qGoal);
//							s = 1;
//							//TODO: Testar a rota
//							//Route* route{qGoal};
//							//percorre a árvore de trás pra frente até chegar em qInit
//							//route->build();  
//						}
//					}
//					i++;
//				}
//			}
//		}
//		int end_t = clock();
//		//cout << "-------------------------------------" << endl;
//		//cout << "Tempo loop: " << (end_t - begin_t) / double(CLOCKS_PER_SEC) << endl;
//	}
//	int stop_s = clock();
//	cout << "Tempo de build: " << (stop_s - start_s) / double(CLOCKS_PER_SEC) * 1000 << endl;
//}

void RRTStar::build(Node* qInit, Node *qGoal, double distanceToGenerateRoute, string envName, string dispersionName){
	build(new NodeStar{ qInit }, new NodeStar{ qGoal }, distanceToGenerateRoute, envName, dispersionName);
}

void RRTStar::build(NodeStar* qInit, NodeStar *qGoal, double distanceToGenerateRoute, string envName, string dispersionName) {
	NodeStar* qRand;
	NodeStar* qNear;
	//double porcentagem_dq = 0.01;
	//double dq = porcentagem_dq * (navigationSpace.getFinalCoordinate()->getX() - navigationSpace.getInitialCoordinate()->getX());
	//distanceToGenerateRoute = 2.0*dq;

	double accumulatedTime = 0, timeDataReport = 0;
	//string experimentName = "grid_compare/";
	string experimentName = "";
	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/RRT_Star/";
	string simulationName = envName + "/rrtstar_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes", "radius_size" };
	//string columns[] = { "iteration", "cost", "sample_time", "add_node_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 6 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };
	
	int planningTimeInit = clock();

	this->setRoot(qInit);
	this->stackNodes.push_back(qInit);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;

	vector<NodeStar*> nodeNeighborhood;
	int s = 0;
	double oldCost = std::numeric_limits<double>::max();
	bool activatePrint = false;

	//while (accumulatedTime <= n) {
	double radius = 0;

	int i = 0;
	int imgCount = 1; int lastQtdNodes = 0;
	double nextTime = 0;
	//while (accumulatedTime <= this->n) {
	for (int i = 1; i <= this->n; i++) {
		//i++;
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		int sampleTimeInit = clock();

		qRand = new NodeStar(this->generateRandomNode());
		this->navigationSpace.putNodeInsideLimits(qRand);
		qNear = (NodeStar*)this->nearestNode(qRand);
		NodeStar* qNew = this->createNewNodeStar(qNear, qRand);

		int sampleTimeEnd = clock();
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);
		int addNewNodeTimeInit = clock();

		currentQNew = qNew;
		radius = this->getRadius();

		if (qNew != NULL) {
			if (collisionChecker.batchCollisionFreePath(qNear, qNew)){
				nodeNeighborhood = this->getNeighborsInRadius(qNew);
				NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);

				this->insertNode(qMin, qNew);
				this->stackNodes.push_back(qNew);
				this->qtdNodes++;

				this->rewire(nodeNeighborhood, qMin, qNew);
		
				double distance = MathUtils::euclidianDistanceNode(qNew, qGoal);
				if (distance <= distanceToGenerateRoute) {
					if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
						double newCost = qNew->getCost() + distance;
						if (oldCost > newCost){
							this->insertNode(qNew, qGoal);

							vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)qInit, (NodeStar*)qGoal);
							NodeStar* rGoal = routeNodes[0];
							NodeStar* rInit = routeNodes[1];							

							Route* newRoute = new Route{ rInit, rGoal };
							newRoute->build();
							this->route = newRoute;
							oldCost = newCost;
							if (activatePrint) {
								displayTimeInit = clock();
								this->displayNow(folderPath + simulationName + "_founded_route_", i);
								displayTimeEnd = clock();
								activatePrint = false;
							}						
						}
					}
				}
					
			}
		}

		int addNewNodeTimeEnd = clock();
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		int init = clock();
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		} else {
			cost = 0;
		}

		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes, radius };
		//float data[] = { i, cost, sampleTime, addNewNodeTime, accumulatedTime };
		//costsByIterationsOutputer->pushData(data, data + sizeOfData);
		//Save the simulation to BMP file
		//if ((i % 500 == 0 && i < 1501) || (i % 2000 == 0 && i > 1501)) {
		/*if (i % 25 == 0 || (i == 1)) {
			this->displayNow(folderPath + simulationName, i);
		}*/

		if (!this->goal->getAntecessor() && (this->qtdNodes - lastQtdNodes) != 0) {
		//if (accumulatedTime <= 0.1 && (accumulatedTime - nextTime) >= 0.0003) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		} else if ((i % 25)==0) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			nextTime = accumulatedTime;
			imgCount++;
		}

		double displayTime = ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));;
		int end = clock();

		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC)); //+displayTime;
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}

	//Increment to count qGoal addition
	this->qtdNodes++;

	//Display to final time
	this->displayNow(folderPath + simulationName, imgCount);
	float data[] = { i, ((NodeStar*)(this->route->getGoal()))->getCost(), 0, accumulatedTime, this->qtdNodes };
	costsByIterationsOutputer->pushData(data, data + sizeOfData);

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	std::cout << "Tempo de planejamento: " << this->planningTime << endl;
	
	//this->displayNow(folderPath + simulationName, this->n);
}

void RRTStar::extend(Node* qNear, NodeStar* qNew) {
	// ALGORITMO RRT* - LINHA 11: verificar o custo do novo nó.
	//NodeStar* costlessNode = this->costlessNodeInNeighborhood((NodeStar*)qNew);
	Node* costlessNode = qNear;
	vector<NodeStar*> nodeNeighborhood = this->getNeighborsInRadius(qNew);

	for (int i = 0; i < nodeNeighborhood.size(); i++) {
		vector<Node*> nodes;
		nodes.push_back(nodeNeighborhood[i]);
		if (collisionChecker.batchCollisionFreePath(nodes, qNew)) {
			//TODO: Verificar esse método costTo do NodeStar
			//double cost = nodeNeighborhood[i]->costToRoot() + nodeNeighborhood[i]->costTo(qNew);
			//Vou considerar o custo entre dois nós sendo a distância euclidiana entre eles.
			double cost = nodeNeighborhood[i]->getCost() +
				MathUtils::euclidianDistanceNode(nodeNeighborhood[i], qNew);
			if (cost < qNew->getCost()) {
				costlessNode = nodeNeighborhood[i];
			}
		}
		nodes.~vector();
	}

	//Linha 13 do algoritmo RRT*
	if (costlessNode != qNear) {
		this->removeNode(qNear, qNew);
		this->insertNode(costlessNode, qNew);
	}

	//Remoção da linha 14
	nodeNeighborhood.erase(remove(nodeNeighborhood.begin(),
									nodeNeighborhood.end(),
									costlessNode), nodeNeighborhood.end());

	for (int i = 0; i < nodeNeighborhood.size(); i++) {
		if (collisionChecker.batchCollisionFreePath(qNew, nodeNeighborhood[i]) &&
			nodeNeighborhood[i]->getCost() > qNew->getCost() + MathUtils::euclidianDistanceNode(qNew, nodeNeighborhood[i])) {
			//Linhas 16 e 17 do Algoritmo RRT*
			this->removeNode(nodeNeighborhood[i]->getAntecessor(), nodeNeighborhood[i]);
			this->insertNode(qNew, nodeNeighborhood[i]);
		}
	}
}

void RRTStar::insertNode(NodeStar * qParent, NodeStar * qChild){
	RRT::insertNode(qParent, qChild);
	//qChild->setCost(qParent->getCost() + MathUtils::euclidianDistanceNode(qParent, qChild));
	//qChild->updateCost();
}

void RRTStar::rewire(vector<NodeStar*> nodeNeighborhood, NodeStar * qMin, NodeStar * qNew){
	for (int i = 0; i < nodeNeighborhood.size(); i++) {
		//Atualiza sempre antes de fazer a comparação pois o mesmo pode ter sido alterado após alguma realocação de aresta.
		//nodeNeighborhood[i]->updateCost();
		if (nodeNeighborhood[i]->getCost() > qNew->getCost() + MathUtils::euclidianDistanceNode(qNew, nodeNeighborhood[i])) {
			if (collisionChecker.batchCollisionFreePath(qNew, nodeNeighborhood[i])){
				if (nodeNeighborhood[i] != qMin) {
					////Linhas 16 e 17 do Algoritmo RRT*
					this->removeNode(nodeNeighborhood[i]->getAntecessor(), nodeNeighborhood[i]);
					this->insertNode(qNew, nodeNeighborhood[i]);
					/*nodeNeighborhood[i]->getAntecessor()->removeSucessor(nodeNeighborhood[i]);
					nodeNeighborhood[i]->setAntecessor(qNew);
					nodeNeighborhood[i]->updateCost();*/
				}
			}
		}
	}
}

vector<NodeStar*> RRTStar::getNeighborsInRadius(NodeStar* node, double radius) {
	vector<NodeStar*> resultNodes;
	//cout << "Node -- " << "x: "<< node->getX() <<"   y: "<< node->getY() << "   radius:" << radius <<endl;

	for (int i = 0; i < this->stackNodes.size(); i++) {
		if (node->getX() != this->stackNodes[i]->getX() || node->getY() != this->stackNodes[i]->getY()) {
			if (MathUtils::euclidianDistanceNode(this->stackNodes[i], node) <= radius) {
				resultNodes.push_back((NodeStar*)this->stackNodes[i]);
			}
		}
	}

	return resultNodes;
}

vector<NodeStar*> RRTStar::getNeighborsInRadius(NodeStar* node) {	
	double radius = this->radiusNeighborhood * sqrt((log(this->qtdNodes) / this->qtdNodes));
	return getNeighborsInRadius(node, radius);
}

double RRTStar::getRadius() {
	return this->radiusNeighborhood * sqrt((log(this->qtdNodes) / this->qtdNodes));
}

Node* RRTStar::getCurrentNew() {
	return currentQNew;
}

// vector<NodeStar*> RRTStar::getNeighborsInRadius(NodeStar* node) {
//	vector<NodeStar*> resultNodes;
//	/*Point_2 circleCenter{node->getX(), node->getY()};
//	Circle_2 circle{circleCenter, this->radiusNeighborhood, CGAL::CLOCKWISE};
//	CGAL::cpp11::result_of<Intersect_2(Circle_2, Point_2)>::type result;
//
//	for (int i = 0; i < stackNodes.size(); i++) {
//		Point_2 nodePoint{ stackNodes[i]->getX(), stackNodes[i]->getY()};
//		if (circle.has_on_positive_side(nodePoint)) {
//			if (stackNodes[i] != node) {
//				resultNodes.push_back((NodeStar*)stackNodes[i]);
//			}
//		}
//	}*/
//	//OBS: this->radiusNeighborhood is beta value from RRT*-Smart
//	//minf = RRT(log(card(V)) = card(V))1 = d; g
//	double radius = this->radiusNeighborhood * sqrt((log(this->qtdNodes)/this->qtdNodes));
//	//double radius = 1;
//
//	for (int i = 0; i < this->stackNodes.size(); i++) {
//		if (node->getX() != this->stackNodes[i]->getX() || node->getY() != this->stackNodes[i]->getY()) {
//			if (MathUtils::euclidianDistanceNode(this->stackNodes[i], node) <= radius) {
//				resultNodes.push_back((NodeStar*)this->stackNodes[i]);
//			}
//		}
//	}
//
//	/*for(int i = 0; i < this->nodesGrid->getCells().size(); i++){
//		vector<Node*> nodes = this->nodesGrid->getCellByIndex(i)->getNodes();
//		for (int j = 0; j < nodes.size(); j++) {
//			if (MathUtils::euclidianDistanceNode(nodes[j], node) <= this->radiusNeighborhood) {
//				resultNodes.push_back((NodeStar*)nodes[j]);
//			}
//		}
//		nodes.~vector();
//	}*/
//
//	return resultNodes;
//}

 NodeStar* RRTStar::createNewNodeStar(Node* qNear, Node*qRand) {
	 Node* newNode = this->createNewNode(qNear, qRand);
	 if(newNode != nullptr){
		 return new NodeStar{ newNode };
	 } 
	 return nullptr;
 }

 NodeStar * RRTStar::chooseParent(vector<NodeStar*> nodeNeighborhood, NodeStar * qNear, NodeStar * qNew) {
	 NodeStar* costlessNode = qNear;
	 //double smallerCost = std::numeric_limits<double>::max();
	 double smallerCost = costlessNode->getCost() + MathUtils::euclidianDistanceNode(costlessNode, qNew);

	 for (int i = 0; i < nodeNeighborhood.size(); i++) {
		 //TODO: Verificar esse método costTo do NodeStar
		 //Considera-se o custo entre dois nós a distância euclidiana entre eles.
		 double cost = nodeNeighborhood[i]->getCost() + MathUtils::euclidianDistanceNode(nodeNeighborhood[i], qNew);
		 if (cost < smallerCost) {
			if (collisionChecker.batchCollisionFreePath(nodeNeighborhood[i], qNew)) {
				costlessNode = nodeNeighborhood[i];
				smallerCost = cost;
			}
		 }
	 }

	 return costlessNode;
 }

 vector<NodeStar*> RRTStar::copyRoute(NodeStar * qInit, NodeStar * qGoal) {
	 //if (!rInit) {
		// rInit = new NodeStar{ qInit->getX(), qInit->getY()};
	 //}

	 //if (!rGoal){
		// rGoal = new NodeStar{ qGoal->getX(), qGoal->getY() };
	 //}

	 vector<NodeStar*> nodes;

	 NodeStar* qCurrent = qGoal;
	 NodeStar* rCurrent = nullptr;
	 
	 NodeStar* rGoal = new NodeStar{ qGoal->getX(), qGoal->getY()};
	 //rGoal->setCost(qGoal->getCost());	 
	 nodes.push_back(rGoal);
	 rCurrent = rGoal;

	 while (true) {
		 if (qCurrent->getAntecessor()) {
			 rCurrent->setAntecessor(new NodeStar(qCurrent->getAntecessor()->getX(), qCurrent->getAntecessor()->getY()));
			 //rCurrent->setAntecessor(new NodeStar(qCurrent));
			 ((NodeStar*)rCurrent->getAntecessor())->setCost(((NodeStar*)qCurrent->getAntecessor())->getCost());
		 }

		 vector<Node*> sucessors = qCurrent->getSucessors();

		 for (int i = 0; i< sucessors.size(); i++) {
			 NodeStar* sucessor = new NodeStar{ sucessors[i]->getX(), sucessors[i]->getY() };
			 //NodeStar* sucessor = new NodeStar{ sucessors[i]};
			 sucessor->setCost(((NodeStar*)sucessors[i])->getCost());
			 rCurrent->addSucessor(sucessor);
		 }

		 qCurrent = (NodeStar*)qCurrent->getAntecessor();
		 rCurrent = (NodeStar*)rCurrent->getAntecessor();

		 if (!rCurrent) {
			 break;
		 } 
		 
		 if (qCurrent->getX() == qInit->getX() && qCurrent->getY() == qInit->getY()) {
			 rCurrent->setStartPosition(true);
			 nodes.push_back(rCurrent);
		 }
	 }

	 
	 return nodes;
 }