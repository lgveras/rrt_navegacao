#include "RRTStarSmart.h"
#include <CGAL/function_objects.h>
#include <CGAL/point_generators_2.h>
#include <CGAL/algorithm.h>
#include "MathUtils.h"
#include "ResultOutputer.h"
#include <string>
#include <chrono>

using namespace std;

typedef CGAL::Creator_uniform_2<double, Point_2> Creator;

RRTStarSmart::RRTStarSmart(NavigationEnvironment ne, const double r, int const n):RRTStar(ne, r, n){
}

RRTStarSmart::~RRTStarSmart(){
}

void RRTStarSmart::build(Node* qInit, Node *qGoal, double distanceToGenerateRoute, string envName) {
	this->build(new NodeStar{ qInit }, new NodeStar{ qGoal }, distanceToGenerateRoute, envName);
}

//
//void RRTStarSmart::build(NodeStar* qInit, NodeStar *qGoal, double distanceToGenerateRoute, string envName) {
//	NodeStar* qRand;
//	NodeStar* qNear;
//	this->setRoot(qInit);
//	int iterationToActivateBias = -1000;
//	bool pathFound= false;
//	double newCost, oldCost = std::numeric_limits<double>::max();
//	vector<NodeStar*> nodeNeighborhood;
//	//execBiasConstant é a constante b do artigo da RRT*-Smart
//	int execBiasConstant = 2, multiplierConstantBias = 1;
//	this->setRoot(qInit);
//	//this->nodesGrid->insertNode(qInit);
//	this->qtdNodes++;
//	int s = 0;	int i = 0;
//
//	double accumulatedTime = 0, timeDataReport = 0;
//
//	//Output file config for data generated by information
//	int seed = navigationSpace.getSeedToRandomGenerator();
//	string fileByIteractionName = "C:/RRTSimulations/byIteration/rrtstar_smart_byIteration_" + envName + "_" + to_string(seed) + ".txt";
//	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
//	char fileSeparator = ';';
//	int sizeOfData = 5 - 1;
//	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };
//
//	int planningTimeInit = clock();
//	//while (s != 1) {
//	for (int i = 0; i <= this->n; i++) {
//		double sampleTime = 0;
//		int sampleTimeInit = clock();
//		cout << "iteracao = " << i << " numero de elementos = " << this->qtdNodes << endl;	//i++;
//		if (i == iterationToActivateBias + (execBiasConstant*multiplierConstantBias)) {
//			qRand = this->generateBiasedNode(i);
//			multiplierConstantBias++;
//		} else {
//			qRand = new NodeStar(this->generateRandomNode());
//		}
//		this->navigationSpace.putNodeInsideLimits(qRand);
//		qNear = (NodeStar*)this->nearestNode(qRand);
//		NodeStar* qNew = this->createNewNodeStar(qNear, qRand);
//		int sampleTimeEnd = clock();
//		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);
//
//		int addNewNodeTimeInit = clock();
//		if (qNew != nullptr) {
//			if (collisionChecker.collisionFreePoint(qNew)) {
//				vector<Node*> nodes;
//				nodes.push_back(qNear);
//				if (collisionChecker.batchCollisionFreePath(nodes, qNew)){
//					nodeNeighborhood = this->getNeighborsInRadius(qNew);
//					NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);
//					this->insertNode(qMin, qNew);
//					this->nodesGrid->insertNode(qNew);
//					this->qtdNodes++;
//					this->rewire(nodeNeighborhood, qMin, qNew);
//					NodeStar* qPathGoal = (NodeStar*)pathCompleted(qNew, qGoal, distanceToGenerateRoute);
//					if (qPathGoal) {
//						iterationToActivateBias = i;
//						pathFound = false;
//						newCost = optimizePath((NodeStar*)qInit, (NodeStar*)qPathGoal);
//						if (newCost < oldCost) {
//							this->goal = qPathGoal;
//							this->beacons = collectBeaconsFromPath((NodeStar*)qInit, (NodeStar*)qPathGoal);
//							oldCost = newCost;
//							s=1;
//						}
//					}				
//				}
//			}
//		}
//		int addNewNodeTimeEnd = clock();
//		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
//
//		int init = clock();
//		accumulatedTime += (sampleTime + addNewNodeTime);
//		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
//		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
//		float data[] = { i, ((NodeStar*)this->goal)->getCost(), sampleTime, accumulatedTime, this->qtdNodes };
//		costsByIterationsOutputer->pushData(data, data + sizeOfData);
//		int end = clock();
//		timeDataReport += (end - init) / double(CLOCKS_PER_SEC);
//		////***FIM GERAÇÃO DE ESTATÍSTICAS***
//	}
//
//	/*if (costsByIterationsOutputer) {
//		costsByIterationsOutputer->closeFile();
//	}*/
//	int planningTimeEnd = clock();
//	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
//}

void RRTStarSmart::build(NodeStar* qInit, NodeStar *qGoal, double distanceToGenerateRoute, string envName) {
	NodeStar* qRand = nullptr;
	NodeStar* qNear;
	bool activatePrint = false;
	//RRT*-Smart parameters: execBiasConstant é a constante b do artigo da RRT*-Smart
	int iterationToActivateBias = -1000;
	//int execBiasConstant = 4, multiplierConstantBias = 1;
	int multiplierConstantBias = 1;
	//float execBiasConstant = 0.02;

	bool pathFound = false;
	double newCost, oldCost = std::numeric_limits<double>::max();
	vector<NodeStar*> nodeNeighborhood;

	double accumulatedTime = 0, timeDataReport = 0;
	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();
	string folderPath = "C:/RRTSimulations/byIteration/RRT_Smart/";
	string simulationName = envName + "/rrtstar_smart_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";
	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	//string columns[] = { "iteration", "cost", "sample_time", "node_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };

	int planningTimeInit = clock();
	
	this->setRoot(qInit);
	//this->nodesGrid->insertNode(qInit);
	this->stackNodes.push_back(qInit);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;
	bool initialPathFounded = false;
	this->selectBeaconGenerator.seed(this->navigationSpace.getSeedToRandomGenerator());

	int s = 0;
	//while (s != 1) {
	// for (int i = 1; i <= this->n; i++) {
	int i = 1;
	int imgCount = 1; int lastQtdNodes = 0;
	double nextTime = 0;
	while (accumulatedTime <= this->n) {
	/*	if (nextTime <= accumulatedTime) {
			this->displayNow(folderPath + simulationName, i);
			i++;
			if (accumulatedTime == 0 || accumulatedTime / ((double)this->n) < 0.03) {
				nextTime = accumulatedTime + (((double)this->n) / 80000.00);
			} else {
				nextTime = accumulatedTime + (((double)this->n) /100.00);
			}
		}*/

		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		auto sampleTimeInit = chrono::high_resolution_clock::now();

		//std::cout << "iteracao = " << i << " numero de elementos = " << this->qtdNodes << endl;//	i++;
		NodeStar* qNew = nullptr;
		//int biasingRatio = floor((this->navigationSpace.getFreeSpaceArea() / this->qtdNodes) *execBiasConstant);
		int biasingRatio = 6;
		if (i == iterationToActivateBias + (biasingRatio*multiplierConstantBias)) {
			//qRand = this->generateBiasedNode(i);
			qNew = this->generateBiasedNode(i);
			multiplierConstantBias++;
		} else {
			qRand = new NodeStar(this->generateRandomNode());
		}

		if (!qNew) {
			this->navigationSpace.putNodeInsideLimits(qRand);
			qNear = (NodeStar*)this->nearestNode(qRand);
			qNew = this->createNewNodeStar(qNear, qRand);
		} else {
			qNear = (NodeStar*)this->nearestNode(qNew);
		}


		/*if(!qNew){

		}else {
			this->navigationSpace.putNodeInsideLimits(qNew);
			qNear = (NodeStar*)this->nearestNode(qNew);
		}*/
		//int sampleTimeEnd = clock();
		auto sampleTimeEnd = chrono::high_resolution_clock::now();

		//sampleTime = double(sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);
		sampleTime = chrono::duration_cast<chrono::nanoseconds>(sampleTimeEnd - sampleTimeInit).count()*1e-9;

		//int addNewNodeTimeInit = clock();
		auto addNewNodeTimeInit = chrono::high_resolution_clock::now();

		if (qNew != nullptr) {
			/*if (collisionChecker.collisionFreePoint(qNew))*/ {
				/*		vector<Node*> nodes;
						nodes.push_back(qNear);*/
				if (collisionChecker.batchCollisionFreePath(qNear, qNew)) {
					nodeNeighborhood = this->getNeighborsInRadius(qNew);
					NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);
					this->insertNode(qMin, qNew);
					this->stackNodes.push_back(qNew);
					//this->nodesGrid->insertNode(qNew);
					this->qtdNodes++;
					this->rewire(nodeNeighborhood, qMin, qNew);

					NodeStar* qPathGoal = nullptr;
					NodeStar* lastAntecessor = nullptr;

					if ((MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) && collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
						lastAntecessor = (NodeStar*)qGoal->getAntecessor();
						if (lastAntecessor) {
							this->removeNode(lastAntecessor, qGoal);
						}
						this->insertNode(qNew, qGoal);
						qPathGoal = (NodeStar*)qGoal;
						initialPathFounded = true;
					}

					if (qPathGoal) {
						//pathFound = false;
						vector<NodeStar*> originalPath = this->copyRoute((NodeStar*)qInit, (NodeStar*)qPathGoal);

						vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)qInit, (NodeStar*)qPathGoal);
						NodeStar* rGoal = routeNodes[0];
						NodeStar* rInit = routeNodes[1];
						newCost = optimizePath(rInit, rGoal);
						//newCost = 10;
						if (initialPathFounded && iterationToActivateBias < 0)
							iterationToActivateBias = i;

						if (newCost < oldCost) {
							//this->goal = qPathGoal;
							Route* newRoute = new Route{ rInit, rGoal };
							//Route* newRoute = new Route{ qInit, qPathGoal };
							newRoute->build();
							newRoute->setOriginalGoal(originalPath[0]);
							this->route = newRoute;
							oldCost = newCost;
							this->beacons = collectBeaconsFromPath(rInit, rGoal);
							if (activatePrint) {
								displayTimeInit = clock();
								this->displayNow(folderPath + simulationName + "_founded_route_", i);
								displayTimeEnd = clock();
								activatePrint = false;
							}
							//displayTimeInit = clock();
							//this->displayNow(folderPath + simulationName + "_founded_route_", i);
							//displayTimeEnd = clock();
							//s = 1;
						} else {
							this->removeNode(qGoal->getAntecessor(), qGoal);
							if (lastAntecessor) {
								this->insertNode(lastAntecessor, qGoal);
								//((NodeStar*)qGoal)->updateCost();
							}
						}
					}
				}
			}
		}
		//int addNewNodeTimeEnd = clock();
		auto addNewNodeTimeEnd = chrono::high_resolution_clock::now();

		//double addNewNodeTime = double(addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		double addNewNodeTime = chrono::duration_cast<chrono::nanoseconds>(addNewNodeTimeEnd - addNewNodeTimeInit).count()*1e-9;
		addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		int init = clock();
		accumulatedTime += (sampleTime + addNewNodeTime);

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		} else {
			cost = 0;
		}

		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes }; 
		i++;
//		float data[] = { i, cost, sampleTime, addNewNodeTime, accumulatedTime };
		//costsByIterationsOutputer->pushData(data, data + sizeOfData);
		//Save the simulation to BMP file
		/*if (i % 250 == 0) {
			this->displayNow(folderPath + simulationName, i);
		}*/
		/*if (!this->goal->getAntecessor() && (this->qtdNodes - lastQtdNodes) > 2 && (accumulatedTime - nextTime) > 0.0012) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		} */
		if (accumulatedTime <= 0.0004 && ((accumulatedTime - nextTime) >= 0.000020)) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		}
		else if (accumulatedTime <= 0.015 && ((accumulatedTime - nextTime) >= 0.0003)) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		}
		else if ((accumulatedTime - nextTime) >= 0.015) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			nextTime = accumulatedTime;
			imgCount++;
		}
		int end = clock();		
		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC)); //+((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	//Display to final time
	this->displayNow(folderPath + simulationName, imgCount);
	float data[] = { i, ((NodeStar*)(this->route->getGoal()))->getCost(), 0, accumulatedTime, this->qtdNodes };
	costsByIterationsOutputer->pushData(data, data + sizeOfData);

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	std::cout << "Tempo de planejamento: " << this->planningTime <<endl;
	//this->displayNow(folderPath + simulationName, this->n);

	/*int t;
	std::cout << "Pressione uma letra para continuar!!";
	while (cin >> t);*/
}

NodeStar* RRTStarSmart::generateBiasedNode(int n) {

	vector<NodeStar*>::iterator init = this->beacons.begin();
	std::template uniform_int_distribution<> distribution(0, std::distance(init, this->beacons.end()) - 1);
	std::template advance(init, distribution(this->selectBeaconGenerator));
	NodeStar* selectedBeacon = (NodeStar*)*init;
	//NodeStar* selectedBeacon = (NodeStar*) MathUtils::vectorRandomSelection<NodeStar*>(this->beacons.begin(), this->beacons.end(), this->navigationSpace.getSeedToRandomGenerator());
	//NodeStar* selectedBeacon = (NodeStar*) MathUtils::vectorRandomSelection<NodeStar*>(this->beacons.begin(), this->beacons.end(), this->navigationSpace.getSeedToRandomGenerator());
	//NodeStar* selectedBeacon = MathUtils::vectorRandomSelection(this->beacons);
	
	std::vector<Point_2> generatedNode;
	//int beaconsRadius = (5000 / 1000.0)*15;
	int beaconsRadius = 15;

	if (!this->randBeaconGenerator) {
		this->randBeaconGenerator = new CGAL::Random(this->navigationSpace.getSeedToRandomGenerator());
	}
	
	CGAL::Random_points_in_disc_2<Point_2, Creator> pointGenerator(beaconsRadius, *this->randBeaconGenerator);
	CGAL::cpp11::copy_n(pointGenerator, 1, std::back_inserter(generatedNode));

	Point_2 generatedPoint = generatedNode.at(0);
	//double nodeX = generatedPoint.x().exact().to_double() + selectedBeacon->getX();
	//double nodeY = generatedPoint.y().exact().to_double() + selectedBeacon->getY();
	double nodeX = generatedPoint.x() + selectedBeacon->getX();
	double nodeY = generatedPoint.y() + selectedBeacon->getY();
	generatedNode.~vector();
	generatedPoint.~Point_2();

	NodeStar* randomNode = new NodeStar(nodeX, nodeY);
	return randomNode;
}

double RRTStarSmart::optimizePath(NodeStar* qInit, NodeStar* qGoal){
	// Last Version - BEGIN
	/*NodeStar* qCurrent = qGoal;
	NodeStar* qVisibilityCheck = (NodeStar*)qGoal;
	while (qVisibilityCheck != qInit) {
		if (!qVisibilityCheck->getAntecessor()->getAntecessor()) {
			qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
			qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);
		}
		else {
			vector<Node*> nodes;
			nodes.push_back(qCurrent);
			if (!collisionChecker.batchCollisionFreePath(nodes, qVisibilityCheck->getAntecessor()->getAntecessor())) {
				qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
				qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);

				qCurrent = (NodeStar*)qCurrent->getAntecessor();
			}
			nodes.~vector();
		}

		qVisibilityCheck = (NodeStar*)qVisibilityCheck->getAntecessor();
	}

	this->updatePathNodesCost(qInit, qGoal);
	return qGoal->getCost();*/
	// Last Version - END
	/*NodeStar* qInit = new NodeStar{ qOriginInit->getX(), qOriginInit->getY() };
	NodeStar* qGoal = new NodeStar{ qOriginGoal->getX(), qOriginGoal->getY() };
	copyRoute(qOriginInit, qOriginGoal, qInit, qGoal);*/

	
	/*vector<NodeStar*> nodes = copyRoute(qOriginInit, qOriginGoal);
	NodeStar* qInit = nodes[1];
	NodeStar* qGoal = nodes[0];*/

	NodeStar* qCurrent = qGoal;
	NodeStar* qVisibilityCheck = qGoal;
	while (qVisibilityCheck != qInit) {
		if (!qVisibilityCheck->getAntecessor()->getAntecessor()) {
			qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
			qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);
		}	else {
			vector<Node*> nodes;
			nodes.push_back(qCurrent);
			if (!collisionChecker.batchCollisionFreePath(nodes, qVisibilityCheck->getAntecessor()->getAntecessor())) {
				qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
				qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);

				qCurrent = (NodeStar*)qCurrent->getAntecessor();
			}
			nodes.~vector();
		}

		qVisibilityCheck = (NodeStar*)qVisibilityCheck->getAntecessor();
	}

	//this->updatePathNodesCost(qInit, qGoal);
	return qGoal->getCost();

/*
	NodeStar* qCurrent = qGoal;
	NodeStar* qVisibilityCheck = (NodeStar*)qGoal;
	while (qVisibilityCheck != qInit) {
		if (!qVisibilityCheck->getAntecessor()->getAntecessor()) {
			qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
			qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);
		} else {
			vector<Node*> nodes;
			nodes.push_back(qCurrent);
			if (!collisionChecker.batchCollisionFreePath(nodes, qVisibilityCheck->getAntecessor()->getAntecessor())) {
				qCurrent->setAntecessor(qVisibilityCheck->getAntecessor());
				qVisibilityCheck->getAntecessor()->addSucessor(qCurrent);

				qCurrent = (NodeStar*)qCurrent->getAntecessor();
			}
			nodes.~vector();
		}
		qVisibilityCheck = (NodeStar*)qVisibilityCheck->getAntecessor();
	}
	
	this->updatePathNodesCost(qInit, qGoal);
	return qGoal->getCost();*/
}

void RRTStarSmart::updatePathNodesCost(NodeStar* qInit, NodeStar* qGoal) {
	NodeStar* qCurrent = qGoal;
	while (qCurrent != qInit) {
		qCurrent->updateCost();
		qCurrent = (NodeStar*)qCurrent->getAntecessor();
	}	
}

vector<NodeStar*> RRTStarSmart::collectBeaconsFromPath(NodeStar* qInit, NodeStar* qGoal){
	vector<NodeStar*> beacons;
	NodeStar* qCurrent = (NodeStar*)qGoal->getAntecessor();
	while (qCurrent != qInit) {
		//qCurrent->updateCost();
		beacons.push_back(qCurrent);
		qCurrent = (NodeStar*)qCurrent->getAntecessor();
	}
	return beacons;
}