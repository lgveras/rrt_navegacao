#include "InformedRRTStar.h"
#include "MathUtils.h"
#include "ResultOutputer.h"
#include <CGAL/point_generators_2.h>
#include <iostream>
#include <chrono>
typedef CGAL::Creator_uniform_2<double, Point_2> Creator;

InformedRRTStar::InformedRRTStar(NavigationEnvironment ne, const double r, int const n) : RRTStar(ne, r, n){
}

InformedRRTStar::InformedRRTStar(NavigationEnvironment ne, const double r, int const n, 
									string experimentName) : RRTStar(ne, r, n) {
	this->experiment = experimentName;
}

InformedRRTStar::~InformedRRTStar(){
}

void InformedRRTStar::build(NodeStar* qInit, NodeStar *qGoal, double distanceToGenerateRoute, string envName) {
	NodeStar* qRand;
	NodeStar* qNear;

	bool activatePrint = false;
	double accumulatedTime = 0, timeDataReport = 0;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();

	string folderPath, simulationName, fileByIteractionName;
	if (this->experiment.size() == 0) {
		folderPath = "C:/RRTSimulations/byIteration/Informed_RRT/";
	} else {
		folderPath = "C:/RRTSimulations/byIteration/" + experiment + "Informed_RRT/";
	}

	simulationName = envName + "/informedrrtstar_byIteration_" + envName + "_" + to_string(seed);
	fileByIteractionName = folderPath + simulationName + ".txt";

	//string folderPath = "C:/RRTSimulations/byIteration/Informed_RRT/";
	//string simulationName = envName + "/informedrrtstar_byIteration_" + envName + "_" + to_string(seed);
	//string fileByIteractionName = folderPath + simulationName + ".txt";

	string columns[] = { "iteration", "cost", "sample_time", "total_time", "nodes" };
	//string columns[] = { "iteration", "cost", "sample_time", "add_node_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* costsByIterationsOutputer = new ResultOutputer{ fileByIteractionName, columns, columns + sizeOfData, fileSeparator };

	int planningTimeInit = clock();

	this->setRoot(qInit);
	this->stackNodes.push_back(qInit);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;

	vector<NodeStar*> nodeNeighborhood;
	int s = 0;
	double oldCost = std::numeric_limits<double>::max();

	//Fill elipse sampling data for the Informed RRT*
	this->configElipseData(qInit, qGoal);

	//while(s == 0){
	//for (int i = 1; i <= this->n; i++) {
	/*int i = 1;
	while (accumulatedTime <= this->n) {*/
		//std::cout << "iteracao = " << i << " numero de elementos = " << this->qtdNodes << endl;// i++;
	/*	if (i % 1000 == 0) {
			this->displayNow(folderPath + simulationName, i);
		}*/
	int i = 0;
	int imgCount = 1; int lastQtdNodes = 0;
	double nextTime = 0;
	while (accumulatedTime <= this->n) {
		/*if (nextTime == 0) {
			this->displayNow(folderPath + simulationName, imgCount);
		}*/
     	i++;
		/*if (nextTime <= accumulatedTime) {
			this->displayNow(folderPath + simulationName, nextTime);
			if (accumulatedTime == 0 || accumulatedTime / ((double)this->n) < 0.03) {
				nextTime = accumulatedTime + (((double)this->n) / 80000.00);
			} else {
				nextTime = accumulatedTime + (((double)this->n) / 200.00);
			}
		}*/
	
		double sampleTime = 0, displayTimeInit = 0, displayTimeEnd = 0;
		//int sampleTimeInit = clock();
		auto sampleTimeInit = chrono::high_resolution_clock::now();

		qRand = this->informedRRTSampling();
			//new NodeStar(this->generateRandomNode());
		this->navigationSpace.putNodeInsideLimits(qRand);
		qNear = (NodeStar*)this->nearestNode(qRand);
		//MODIFICAÇÃO PARA IMPLEMENTAR A INFORMED RRT*
		//NodeStar* qNew = this->informedRRTSampling(qNear, qRand);
		NodeStar* qNew = this->createNewNodeStar(qNear, qRand);

		//int sampleTimeEnd = clock();
		auto sampleTimeEnd = chrono::high_resolution_clock::now();

		//sampleTime = double(sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);
		sampleTime = chrono::duration_cast<chrono::nanoseconds>(sampleTimeEnd - sampleTimeInit).count()*1e-9;

		//int addNewNodeTimeInit = clock();
		auto addNewNodeTimeInit = chrono::high_resolution_clock::now();

		if (qNew != NULL) {
			//if (collisionChecker.collisionFreePoint(qNew)) {
			/*vector<Node*> nodes;
			nodes.push_back(qNear);*/
			if (collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeNeighborhood = this->getNeighborsInRadius(qNew);
				NodeStar* qMin = this->chooseParent(nodeNeighborhood, qNear, qNew);

				this->insertNode(qMin, qNew);
				this->stackNodes.push_back(qNew);
				this->qtdNodes++;

				this->rewire(nodeNeighborhood, qMin, qNew);

				double distanceToGoal = MathUtils::euclidianDistanceNode(qNew, qGoal);
				if (distanceToGoal <= distanceToGenerateRoute) {
					/*vector<Node*> nodes;
					nodes.push_back(qNew);*/
					if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
						double newCost = qNew->getCost() + distanceToGoal;
						if (oldCost > newCost) {
							this->insertNode(qNew, qGoal);

							vector<NodeStar*> routeNodes = this->copyRoute((NodeStar*)qInit, (NodeStar*)qGoal);
							NodeStar* rGoal = routeNodes[0];
							NodeStar* rInit = routeNodes[1];

							rInit->setStartPosition(true);
							Route* newRoute = new Route{ rInit, rGoal };
							newRoute->build();
							this->route = newRoute;

							if (activatePrint) {
								displayTimeInit = clock();
								this->displayNow(folderPath + simulationName + "_founded_route_", i);
								displayTimeEnd = clock();
								activatePrint = false;
							}

							//displayTimeInit = clock();
							////this->displayNow(folderPath + simulationName + "_founded_route_", i);
							//displayTimeEnd = clock();
							oldCost = newCost;

							updateTransformingData(newCost);
							//this->goal = qNew;
							//s = 1;
						}
					}
				}

			}
		}
		//int addNewNodeTimeEnd = clock();
		auto addNewNodeTimeEnd = chrono::high_resolution_clock::now();

		//double addNewNodeTime = double(addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);
		double addNewNodeTime = chrono::duration_cast<chrono::nanoseconds>(addNewNodeTimeEnd - addNewNodeTimeInit).count()*1e-9;
		addNewNodeTime = addNewNodeTime - ((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));

		accumulatedTime += (sampleTime + addNewNodeTime);
		int init = clock();

		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "cost", "sample_time", "total_time", "nodes"};
		double cost;
		if (this->route) {
			cost = ((NodeStar*)(this->route->getGoal()))->getCost();
		} else {
			cost = 0;
		}

		float data[] = { i, cost, sampleTime, accumulatedTime, this->qtdNodes }; 
		costsByIterationsOutputer->pushData(data, data + sizeOfData);

		//i++;
		//float data[] = { i, cost, sampleTime, addNewNodeTime, accumulatedTime };
		/*if (!this->goal->getAntecessor() && (this->qtdNodes - lastQtdNodes) >= 2 && (accumulatedTime - nextTime) > 0.0012) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		} else

		/*if (accumulatedTime <= 0.0004 && ((accumulatedTime - nextTime) >= 0.000020)) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		}
		else if (accumulatedTime <= 0.015 && ((accumulatedTime - nextTime) >= 0.0003)) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			lastQtdNodes = this->qtdNodes;
			nextTime = accumulatedTime;
			imgCount++;
		} else if ((accumulatedTime - nextTime) >= 0.015) {
			this->displayNow(folderPath + simulationName, imgCount);
			costsByIterationsOutputer->pushData(data, data + sizeOfData);
			nextTime = accumulatedTime;
			imgCount++;
		}*/

		//Save the simulation to BMP file
		//if (i % 250 == 0) {
		//	//this->displayNow(folderPath + simulationName, i);
		//}
		int end = clock();
		timeDataReport += ((end - init) / double(CLOCKS_PER_SEC)); //+((displayTimeEnd - displayTimeInit) / double(CLOCKS_PER_SEC));
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}

	//Increment to count qGoal addition
	this->qtdNodes++;

	//Display to final time
	//this->displayNow(folderPath + simulationName, imgCount);
	float data[] = { i, ((NodeStar*)(this->route->getGoal()))->getCost(), 0, accumulatedTime, this->qtdNodes };
	costsByIterationsOutputer->pushData(data, data + sizeOfData);

	int planningTimeEnd = clock();
	this->planningTime = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	std::cout << "Tempo de planejamento: " << this->planningTime << endl;

	//this->displayNow(folderPath + simulationName, this->n);
}

NodeStar* InformedRRTStar::informedRRTSampling() {
	//if (this->route) {
	if (this->goal->getAntecessor()) {
		Point_2 generatedPoint = getRandomPointOnDisc();
		double x = (generatedPoint.x());
		double y = (generatedPoint.y());
		//cout << x << "\t" << y << endl;
		Point_2 transformedPoint = circle2Elipse(x, y);
		//Point_2 transformedPoint = circle2Elipse(generatedPoint.x(), generatedPoint.y());
		//cout << "Outside: " << transformedPoint.x() << "\t" << transformedPoint.y() << endl;
	/*	if (transformedPoint.x() <= this->navigationSpace.getFinalCoordinate()->getX() &&
			transformedPoint.y() <= this->navigationSpace.getFinalCoordinate()->getY()) {*/
		return new NodeStar(transformedPoint.x(), transformedPoint.y());
		//return this->createNewNodeStar(qNear, new NodeStar(transformedPoint.x(), transformedPoint.y()));
	/*	} else {
			return nullptr;
		}*/
	} else {
		Node* random = this->generateRandomNode();
		return new NodeStar(random);
		//return this->createNewNodeStar(qNear, qRand);
	}
}

Point_2 InformedRRTStar::getRandomPointOnDisc() {
	std::vector<Point_2> generatedSample;
	if (!this->randBeaconGenerator) {
		this->randBeaconGenerator = new CGAL::Random(this->navigationSpace.getSeedToRandomGenerator());
	}

	CGAL::Random_points_in_disc_2<Point_2, Creator> pointGenerator(1, *this->randBeaconGenerator);
	CGAL::cpp11::copy_n(pointGenerator, 1, std::back_inserter(generatedSample));

	return generatedSample.at(0);
}

void InformedRRTStar::configElipseData(NodeStar* qInit, NodeStar* qGoal) {
	Eigen::Vector2d focus1(qInit->getX(), qInit->getY());
	//cout << "Init: " << qInit->getX() << "\t" << qInit->getY() << endl;
	//cout << "focus 1: " << focus1[0] << "\t" << focus1[1] << endl;
	Eigen::Vector2d focus2(qGoal->getX(), qGoal->getY());
	//cout << "Goal: " << qGoal->getX() << "\t" << qGoal->getY() << endl;
	//cout << "focus 2: " << focus2[0] << "\t" << focus2[1] << endl;
	//Calc center point of the elipse to translate the result transformation
	this->center = 0.5*(focus1 + focus2);
	//Min transverse diameter is the closest distante between qinit and qgoal
	this->minTransverseDiameter = (focus1 - focus2).norm();
	//Calc rotation matrix by Wahba problem
	this->rotationMatrix = calcRotationToWorldFrame(focus1, focus2);
}

void InformedRRTStar::updateTransformingData(double currentCost) {
	transformationMatrix = calcTransformation(currentCost);
}

Eigen::Matrix2d InformedRRTStar::calcRotationToWorldFrame(Eigen::Vector2d focus1, Eigen::Vector2d focus2) {
	//De acordo com o código do Gammel na lib ompl
	//*dim é a dimensão do ambiente de navegação. No meu trabaho é dim = 2;
	int dim = 2;
	//#1 define o eixo transversal da elipse.
	Eigen::Vector2d transverseAxis = (focus2 - focus1) / minTransverseDiameter;

	//Wabah Step 1: 
	//#2 define o problema de Wahba, representado por uma matrix de dimensão (dim, dim)
	//a variavél wahbaProb é a matrix B da descrição do problema de Wahba.
	Eigen::Matrix2d wahbaProb;
	//wahbaProb = Eigen::Matrix2d::Identity().col(0).transpose() * transverseAxis;
	//Eigen::Vector2d referenceVector = Eigen::Matrix2d::Identity().col(0).transpose();
	wahbaProb = transverseAxis * Eigen::Matrix2d::Identity().col(0).transpose();

	//Wabah Step 2:
	//#3 gera as matrizes unitárias U e V do problema de Wahba pelo solver Eigen do problema de decomposição de valor singular (SVD problem)
	Eigen::JacobiSVD<Eigen::Matrix2d, Eigen::NoQRPreconditioner> svd(wahbaProb, Eigen::ComputeFullV | Eigen::ComputeFullU);

	///Wabah Step 3:
	//#4 define a matriz diagonal do problema de Wahba, com os valores da diagonal principal iguais a 1
	Eigen::Vector2d middleM = Eigen::Vector2d::Ones();
	//#5 Make the last value equal to det(U)*det(V) (zero-based indexing remember)
	middleM(dim - 1) = svd.matrixU().determinant() * svd.matrixV().determinant();
	//Calculate the rotation matrix from the wahba problem
	Eigen::Matrix2d result = svd.matrixU() * middleM.asDiagonal() * svd.matrixV().transpose();
	return result;
}

Eigen::Matrix2d InformedRRTStar::calcTransformation(double currentCost) {
	//De acordo com o código do Gammel na lib ompl e Fig4. do artigo dele da Informed RRT*
	double transverseDiameter = currentCost;
	double conjugateDiameter = std::sqrt(transverseDiameter * transverseDiameter - minTransverseDiameter * minTransverseDiameter);
	// Cria um vetor dos raios de cada diagonal
	Eigen::Vector2d diagonalAsVector;
	// All the elements but one are the conjugate radius
	diagonalAsVector.fill(conjugateDiameter / 2.0);
	//cout << "conjugateDiamater: " << conjugateDiameter << endl;
	// The first element in diagonal is the transverse radius
	diagonalAsVector(0) = transverseDiameter / 2.0;
	//cout << "transverseDiameter: " << transverseDiameter << endl;
	//#1 define o eixo transversal da elipse.
	// calcula a matrix de tranformção multiplicando o vetor pela matriz de rotação
	Eigen::Matrix2d result = rotationMatrix * diagonalAsVector.asDiagonal();
	return result;
}

Point_2 InformedRRTStar::circle2Elipse(double x, double y) {
	Eigen::Vector2d point; point << x, y;
	Eigen::Vector2d transformedPoint = (transformationMatrix * point);
	//cout << "Before center: " << transformedPoint(0) << "\t" << transformedPoint(1) << endl;
	transformedPoint = transformedPoint + this->center;
	//cout << "After center: " << transformedPoint(0) << "\t" << transformedPoint(1) << endl;
	return Point_2(transformedPoint(0), transformedPoint(1));
}