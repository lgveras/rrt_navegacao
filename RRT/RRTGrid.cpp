#include "RRTGrid.h"
#include "GridEnum.h"
#include "ResultOutputer.h"

RRTGrid::RRTGrid(NavigationEnvironment ne, int const n):RRT(ne, n){
}

RRTGrid::~RRTGrid(){
}

void RRTGrid::build(Node* qInit, Node *qGoal, double distanceToGenerateRoute, string envName, int numberCells) {
	Node* qRand;
	Node* qNear;
	double accumulatedTime = 0, timeDataReport = 0;
	bool foundedNewPath = false;

	//Output file config for data generated by information
	int seed = navigationSpace.getSeedToRandomGenerator();

	string folder;
	string simulation;

	if (this->navigationSpace.getGridType() == GridEnum::LATTICE_GRID) {
		folder = "RRT_Grid/Lattice";
		simulation = "rrt_grid_lattice";
	} else if(this->navigationSpace.getGridType() == GridEnum::SUKHAREV_GRID) {
		folder = "RRT_Grid/Sukharev";
		simulation = "rrt_grid_sukharev";
	}

	string folderPath = "C:/RRTSimulations/byIteration/"+folder+"/";
	string simulationName = envName + "/" + simulation + "_" + to_string(numberCells) + "_grid_byIteration_" + envName + "_" + to_string(seed);
	string fileByIteractionName = folderPath + simulationName + ".txt";

	string columns[] = { "iteration",  "cost", "sample_time", "total_time", "nodes" };
	char fileSeparator = ';';
	int sizeOfData = 5 - 1;
	ResultOutputer* byIterationsOutputer = new ResultOutputer{fileByIteractionName, columns, columns + sizeOfData, fileSeparator};

	double planningTimeInit = clock();

	this->setRoot(qInit);
	this->stackNodes.push_back(qInit);
	this->qtdNodes++;
	this->goal = qGoal;
	this->distanceToGoal = distanceToGenerateRoute;

	int i = 0;
	while (foundedNewPath == false) {
		/*this->displayNow(folderPath + simulationName + "_example_", 0);
		break;*/
		i++;
		double sampleTime = 0;
		int sampleTimeInit = clock();

		qRand =  this->generateRandomNode();
		qNear = (Node*)this->nearestNode(qRand);
		Node* qNew = nullptr; int nodeEncountered = 0;

		this->navigationSpace.putNodeInsideLimits(qRand);

		//Primeira tentativa de qNew: Grade de sukharev
		if (this->navigationSpace.getDispersionGrid().getGridSize() != 0 && nodeEncountered == 0) {
			if (this->navigationSpace.getGridType() == GridEnum::SUKHAREV_GRID) {
				Node* qNewTemp;
				qNewTemp = this->createNewNodeBySulharevGrid(qNear, qRand);
				this->navigationSpace.putNodeInsideLimits(qNewTemp);
			/*	int centroid = this->navigationSpace.getDispersionGrid().getCentroidIndex(qNewTemp);
				Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNoVisitedCentroidByIndex(centroid);*/
				Node* qNewSukharev = this->navigationSpace.getDispersionGrid().getNearestCentroid(qNewTemp);
				if (qNewSukharev != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewSukharev)) {
					qNewSukharev->visite();
					qNew = qNewSukharev->createCopy();
					nodeEncountered = 1;
				}
			} else if (this->navigationSpace.getGridType() == GridEnum::LATTICE_GRID) {
				Node* qNewTemp = this->createNewNodeBySulharevGrid(qNear, qRand);//ajutar o calculo de qNewRand para o valor da dispersão do lattice
				Node* qNewLattice = this->navigationSpace.getDispersionGrid().getNearestCentroid(qNewTemp);
				if (qNewLattice != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNewLattice)) {
					qNewLattice->visite();
					qNew = qNewLattice->createCopy();
					nodeEncountered = 1;
				}
			}
		}

		//Segunda tentativa de qNew: Ponto aleatório (Abordagem tradicional)
		if (nodeEncountered == 0) {
			qNew = this->createNewNode(qNear, qRand);
			if (qNew != nullptr && collisionChecker.batchCollisionFreePath(qNear, qNew)) {
				nodeEncountered = 1;
			}
		}

		int sampleTimeEnd = clock();
		sampleTime = (sampleTimeEnd - sampleTimeInit) / double(CLOCKS_PER_SEC);

		int addNewNodeTimeInit = clock();
		if (qNew != nullptr && nodeEncountered == 1) {
			this->insertNode(qNear, qNew);
			this->stackNodes.push_back(qNew);
			this->qtdNodes++;

			if (MathUtils::euclidianDistanceNode(qNew, qGoal) <= distanceToGenerateRoute) {
				if (collisionChecker.batchCollisionFreePath(qNew, qGoal)) {
					this->insertNode(qNew, qGoal);

					Route* newRoute = new Route{ qInit, qGoal};
					newRoute->build();
					this->route = newRoute;
					
					this->displayNow(folderPath + simulationName + "_founded_route_", i);
 					foundedNewPath = true;
				}
			}
		}

		int addNewNodeTimeEnd = clock();
		double addNewNodeTime = (addNewNodeTimeEnd - addNewNodeTimeInit) / double(CLOCKS_PER_SEC);

		int init = clock();
		accumulatedTime += (sampleTime + addNewNodeTime);
		////***INICIO GERAÇÃO DE ESTATÍSTICAS***
		//Save data to current iterator {"Iteration", "sample_time", "total_time", "nodes"};		
		float data[] = { i, ((NodeStar*)this->goal)->getCost(), sampleTime, accumulatedTime, this->qtdNodes };
		byIterationsOutputer->pushData(data, data + sizeOfData);
		//Save the simulation to BMP file
	/*	if (i % 250 == 0) {
			this->displayNow(folderPath + simulationName, i);
		}*/
		int end = clock();
		timeDataReport += (end - init) / double(CLOCKS_PER_SEC);
		////***FIM GERAÇÃO DE ESTATÍSTICAS***
	}
	//Increment to count qGoal addition
	this->qtdNodes++;

	int planningTimeEnd = clock();
	double time = ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport;
	this->planningTime = time <= 0 ? 0 : time;
	///*std::cout << "planningTimeEnd: " << planningTimeEnd << ";  planningTimeInit: " << planningTimeInit << "; clock:" << double(CLOCKS_PER_SEC) << ";  timeDataReport: " << timeDataReport << endl;
	std::cout << "Tempo de planejamento: " << this->planningTime << endl;
	//std::cout << "Tempo: " << ((planningTimeEnd - planningTimeInit) / double(CLOCKS_PER_SEC)) - timeDataReport << endl;
}

Node * RRTGrid::createNewNodeBySulharevGrid(Node * qNear, Node * qRand){
	Node* qNew;

	/*if (qNear->getX() == qNear->getY()) {
	qNew = new NodeStar{ qNear};*/
	
	double dispersion = this->navigationSpace.getDispersionGrid().getDispersion();
	/*if (this->qtdNodes == 2) {
		cout << "dispersion: " << dispersion << endl;
	}*/

	double deltaQ;
	if (dispersion > 0) {
		deltaQ = dispersion;
	} else {
		double sideCellX = this->navigationSpace.getDispersionGrid().getStepCentroidPositionLat();
		double sideCellY = this->navigationSpace.getDispersionGrid().getStepCentroidPositionLong();
		deltaQ = std::sqrt(pow(sideCellX, 2) + pow(sideCellY, 2));
	}

	//cout << "dispersion" << dispersion << endl;
	//cout << "valor" << valor << endl;
	double qNearX = qNear->getNodeWaypoint()->getLatitude(), qNearY = qNear->getNodeWaypoint()->getLongitude();
	double qRandX = qRand->getNodeWaypoint()->getLatitude(), qRandY = qRand->getNodeWaypoint()->getLongitude();

	double hipotenusa, deltaQLat, deltaQLong, porcentagemDeltaQ, catetoSin, catetoCos, senoTeta, cosTeta, vetorULat, vetorULong;

	hipotenusa = MathUtils::euclidianDistanceNode(qNear, qRand);

	catetoCos = qRandX - qNearX;
	catetoSin = qRandY - qNearY;

	cosTeta = catetoCos / hipotenusa;
	vetorULat = qNear->getNodeWaypoint()->getLatitude() + (cosTeta)*deltaQ;
	senoTeta = catetoSin / hipotenusa;
	vetorULong = qNear->getNodeWaypoint()->getLongitude() + (senoTeta)*deltaQ;

	qNew = new Node{ vetorULat, vetorULong };

	return qNew;
}